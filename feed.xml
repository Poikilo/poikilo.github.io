<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MMM</title>
  
  <subtitle>WWW를 뒤집어보기</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://poikilo.github.io/"/>
  <updated>2020-03-02T21:46:28.915Z</updated>
  <id>https://poikilo.github.io/</id>
  
  <author>
    <name>Yonghyun Kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Confluence TIP</title>
    <link href="https://poikilo.github.io/2020/03/02/confluence-tip/"/>
    <id>https://poikilo.github.io/2020/03/02/confluence-tip/</id>
    <published>2020-03-02T08:43:10.000Z</published>
    <updated>2020-03-02T21:46:28.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>Confluence 활용 팁을 정리한다.  </p><h2 id="Short-cuts-단축키"><a href="#Short-cuts-단축키" class="headerlink" title="Short cuts. (단축키)"></a>Short cuts. (단축키)</h2><p>자주 사용하는 단축키를 정리한다.  </p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td>e</td><td>페이지 편집</td></tr><tr><td>“—-“</td><td>가로 줄 넣기</td></tr><tr><td>ctrl+shift+i</td><td>표 생성</td></tr><tr><td>alt+방향키(위/아래)</td><td>표에서 행 추가</td></tr><tr><td>h{number}.</td><td>서식 지정(제목/ 본문)</td></tr><tr><td>ctrl+{number}</td><td>서식 지정(제목/ 본문)</td></tr><tr><td>[]</td><td>Todo 지정</td></tr><tr><td>//</td><td>Date picker.</td></tr><tr><td>@</td><td>mention</td></tr><tr><td>ctrl+s</td><td>저장 - 제목 편집중에는 작동하지 않는다.</td></tr><tr><td>–&gt;</td><td>화살표 방향대로. dash를 두개 넣으면 자동 변환한다.</td></tr><tr><td>*</td><td>목록화 하여 표시할 내용이 있다면 사용. Tab 키를 통해 Level을 맞출 수 있다.</td></tr><tr><td>ctrl+z</td><td>되돌리기. 매크로나, 자동변경사항을 돌릴 수 있다.</td></tr><tr><td>[link-url]</td><td>링크</td></tr></tbody></table><h2 id="개인공간-Style-지정"><a href="#개인공간-Style-지정" class="headerlink" title="개인공간 Style 지정."></a>개인공간 Style 지정.</h2><p>side bar의 하단에 있는 톱니바퀴 버튼(공간 도구) 클릭.<br>모양새 선택<br>색상 구성 선택<br><a href="https://www.webdesignrankings.com/resources/lolcolors/" target="_blank" rel="noopener">Hexa code 링크</a> 참고하여 기존 Confluence style에서 벗어나자..<br>폰트의 변경은 아래를 참고한다  </p><ul><li>D2 coding 스타일 적용.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@import url(&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Joungkyun&#x2F;font-d2coding@1.31.0&#x2F;d2coding.css&#39;);</span><br><span class="line">@import url(&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Joungkyun&#x2F;font-d2coding@1.31.0&#x2F;d2coding-ligature.css&#39;);</span><br><span class="line">body &#123; font-family: &#39;D2 coding Ligature&#39;;&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;Confluence 활용 팁을 정리한다.  &lt;/p&gt;
&lt;h2 id=&quot;Short-cuts-단축키&quot;&gt;&lt;a href=&quot;#Short-c
      
    
    </summary>
    
    
    
      <category term="atlassian" scheme="https://poikilo.github.io/tags/atlassian/"/>
    
      <category term="wiki" scheme="https://poikilo.github.io/tags/wiki/"/>
    
      <category term="confluence" scheme="https://poikilo.github.io/tags/confluence/"/>
    
  </entry>
  
  <entry>
    <title>JIRA Tip</title>
    <link href="https://poikilo.github.io/2020/03/02/jira-tip/"/>
    <id>https://poikilo.github.io/2020/03/02/jira-tip/</id>
    <published>2020-03-02T08:23:30.000Z</published>
    <updated>2020-03-02T21:46:28.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-용어-정리"><a href="#01-용어-정리" class="headerlink" title="01. 용어 정리"></a>01. 용어 정리</h2><ul><li>Projects<br>프로젝트는 같은 목적 또는 공동의 맥락을 가진 이슈들의 집합이다.</li><li>Issue<br>이슈는 사이즈 무관의 단위 작업을 뜻하며, 시작과 종료까지 Tracking이 필요한 작업을 의미한다.<br>다른 말로는 Requests, Tickets, Tasks로 불린다.  </li><li>Workflow<br>이슈의 단계는 여러가지가 될 수 있다. 워크 플로우는 이슈 처리에 대한 일련의 작업상태를 뜻한다.<br>예시로, Open -&gt; In Progress -&gt; Under Review -&gt; Final Approval -&gt; Done.<br>최종 완료상태인 Done/Resolved/Closed를 제외한 각 단계는 서로 ping-pong이 가능하다.  </li><li>Agile<br>Agile은 소프트웨어 개발 방법론 중 하나로, 고객의 요청(요구사항)에 따라 빠른 프로토타이핑을 진행하며 Feedback을 통해 소프트웨어를 개선해 나가는 작업을 수행한다.<br>지속적인 개발을 통해 서비스를 개선해 나가는 작업에 적합하다. (B2C 서비스들)<br>빠른 프로토타이핑을 통해 고객의 의견수렴에 적응이 빠르다.  </li></ul><h2 id="Start-with-6-Steps"><a href="#Start-with-6-Steps" class="headerlink" title="Start with 6 Steps."></a>Start with 6 Steps.</h2><p><strong>Step 1. Create Project</strong><br><strong>Step 2. Pick a Template</strong><br>  Template(Scrum, Kanban, Bug Tracking) 제공.<br>  팀이나 회사에서 Template을 잘 만들어서 관리하면 산출물 작성에 큰 도움이 된다.<br><strong>Step 3. Board Setup</strong><br>  할당된 Issue, 진행중 Issue 등 프로젝트에서 진행하고 있는 Issue에 대한 Dashboard를 제공한다.<br>  이를 개인의 목적에 맞게 적용하여 개인 Dashboard에서 활용할 수 있다.<br><strong>Step 4. Issue 생성</strong><br>  Back log에 Issue가 생성된다.<br><strong>Step 5. 팀원 초대</strong><br>  프로젝트에 참여하는 팀원을 초대한다.<br><strong>Step 6. Workflow Setup</strong><br>  Board에서 할당된 Issue의 진행사항등을 Drag &amp; Drop을 통해 상태를 변경한다.  </p><h2 id="JQL"><a href="#JQL" class="headerlink" title="JQL"></a>JQL</h2><p>Jira의 데이터를 조회할때 사용하는 Query Language이다.<br>잘 사용하면 프로젝트, 이슈의 종류, 일정관리 등에 도움이 된다.<br>DB Query(SQL)을 알고 있는 사용자라면, 좀 더 쉽게 배울 수 있다.</p><ul><li>사용 예<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 현재 로그인 한 사용자에게 할당된 이슈 검색.</span><br><span class="line">assignee &#x3D; currentUser()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 내가 담당자인 이슈 중, 처리되지 않은 이슈 검색</span><br><span class="line">assignee &#x3D; currentUser() and status not in (resolved, closed, done)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 특정 이슈의 하위 이슈(sub-task) 검색</span><br><span class="line">Project &#x3D; &#123;project_name&#125; and parent &#x3D; &#123;issue_key&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 지난주에 상태를 변경한 이슈</span><br><span class="line">status changed during (startOfWeek(-1), endOfWeek(-1)) order by updatedDate</span><br></pre></td></tr></table></figure></li></ul><h2 id="개인에게-할당된-월별-이슈-조회"><a href="#개인에게-할당된-월별-이슈-조회" class="headerlink" title="개인에게 할당된 월별 이슈 조회"></a>개인에게 할당된 월별 이슈 조회</h2><p>개인의 filter를 사용하면 훨씬 더 간단해 지겠지만, JIRA를 건드리지 않고 조회하는 JQL을 설명한다.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2020-03에 생성된 이슈이면서, 아직 완료되지 않은 건.</span><br><span class="line">assignee &#x3D; currentUser() and status not in (closed, resolved, done) and createdDate &lt;&#x3D; &#39;2020-03-01&#39; and createdDate &lt; &#39;2020-04-01&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2020-03 이전에 생성된 이슈이면서, 아직 완료되지 않은 건.</span><br><span class="line">assignee &#x3D; currentUser() and status not in (closed, resolved, done) and  createdDate &lt; &#39;2020-03-01&#39;</span><br></pre></td></tr></table></figure><p>Confluence의 Jira Macro를 활용하여 사용한다면, 매달의 현황을 체크할 수 있다.  </p><h2 id="Issue의-Tag-활용"><a href="#Issue의-Tag-활용" class="headerlink" title="Issue의 Tag 활용"></a>Issue의 Tag 활용</h2><p>개발 팀명, 프로젝트 기간, 이슈 타입, 개인화 태그를 추가하면 검색에 좀 더 용이할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;01-용어-정리&quot;&gt;&lt;a href=&quot;#01-용어-정리&quot; class=&quot;headerlink&quot; title=&quot;01. 용어 정리&quot;&gt;&lt;/a&gt;01. 용어 정리&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Projects&lt;br&gt;프로젝트는 같은 목적 또는 공동의 맥락을 가진 
      
    
    </summary>
    
    
    
      <category term="jira" scheme="https://poikilo.github.io/tags/jira/"/>
    
      <category term="atlassian" scheme="https://poikilo.github.io/tags/atlassian/"/>
    
      <category term="issue" scheme="https://poikilo.github.io/tags/issue/"/>
    
      <category term="tracker" scheme="https://poikilo.github.io/tags/tracker/"/>
    
  </entry>
  
  <entry>
    <title>버전관리 도구</title>
    <link href="https://poikilo.github.io/2020/03/02/version-control/"/>
    <id>https://poikilo.github.io/2020/03/02/version-control/</id>
    <published>2020-03-02T06:03:40.000Z</published>
    <updated>2020-03-02T21:46:28.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Configuration-Management-CM-형상관리"><a href="#Configuration-Management-CM-형상관리" class="headerlink" title="Configuration Management(CM; 형상관리)"></a>Configuration Management(CM; 형상관리)</h2><ul><li><p><strong>Definition</strong><br>CM(형상관리)은 제품의 성능, 기능성, 요구사항 중 물리적 조건, 디자인 제품의 생명주기 전반에 걸친 운영에 필요한 정보 등을 ㅗ구성된 구축과 유지보수에 대한 시스템 엔지니어링 프로세스 이다.<br>쉽게 말해서, 제품을 만들고 유지관리하는데 수반되는 프로세스라 생각하면 된다.  </p></li><li><p><strong>SCM(Software Configuration Management; 소프트웨어 형상관리)</strong><br>소프트웨어를 개발, 유지보수 하는데 있어 소프트웨어의 변경사항 뿐만 아니라 관련 산출물들에 대한 변경사항을 추적/ 통제하기 위한 프로세스이다.  </p></li><li><p><strong>SDLC(Software Development LifeCycle; 소프트웨어 개발 생명주기)</strong><br>소프트웨어의 개발 생명주기. 보통 생각하는 요구사항 분석 - 설계 - 개발 - 테스트 - 이행(배포) - 모니터링 정도로 생각하면 된다.<br>SCM은 SDLC의 각 단계별 산출물과, 소스코드의 변경을 추적 관리한다.</p></li><li><p><strong>필요성</strong><br>혼자 개발하는 경우가 거의 없기 때문에.<br>개발자(SI)와 운영자(SM)는 다른 경우가 대부분이기 때문에.<br>시스템의 규모가 클 수록 변경사항에 대한 체계적 관리가 필요해졌기 때문에.</p></li><li><p><strong>개인 의견</strong><br>흔히 형상관리 하면 소스코드의 버전관리를 생각하는 경우가 대부분이다.<br>정의에 담겨있듯, 단순히 소스코드의 버전관리가 아니라 SDLC에서 도출되는 모든 산출물이 그 대상이라고 할 수 있다.<br>기업마다 관리하는 프로세스의 정도(Level)이 다르기 때문에, 그 범위가 다르다.<br>간단한 예로, 자동차에 들어가는 소프트웨어 개발 품질관리 정책과 웹 서비스에 필요한 소프트웨어 개발 프로세스 정책은 확실히 다르다.<br>critical한 시스템일 수록 소프트웨어에 대한 품질관리가 철저히 이루어져야 하며 국제 표준또한 많이 나와있다. A-SPICE, ISO-26262 등  </p></li></ul><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul><li><strong>Git</strong><br>파일의 변경사항을 추적하고, 여러명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전관리 시스템이다.<br>대개 소스코드 관리에 사용되지만, 어떤 집합의 파일의 변경사항을 지속적으로 추적하기 위해 사용될 수 있다.(e.g., 산출물 - 기획문서 등 version 관리 가능)<br>Git을 기반으로 사용하는 다양한 툴이 개발되어 있다.<br>Git의 장점은 브랜치 관리 - <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow" target="_blank" rel="noopener">git flow 참고 - Atlassian bitbucket tutorial</a><br><a href="https://github.com" target="_blank" rel="noopener">github</a><br><a href="https://gitlab.com" target="_blank" rel="noopener">gitlab</a><br><a href="https://bitbucket.com" target="_blank" rel="noopener">bitbucket</a>  </li><li><strong>Subversion</strong><br>Apache 프로젝트, Server-client 모델을 따른 시스템이다.<br>서버에 저장소를 두고, 클라이언트에서 push pull 작업을 진행한다.<br>Eclipse-java 프로젝트를 진행하며 회사에서 사용 해 보았다. 서버에 설치가 간단하며, CLI, GUI 환경 모두 지원한다.<br>windows 계열에는 visual svn(server), tortoiseSVN(client)<br>Linux 계열에는 subversion 설치 확인.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Configuration-Management-CM-형상관리&quot;&gt;&lt;a href=&quot;#Configuration-Management-CM-형상관리&quot; class=&quot;headerlink&quot; title=&quot;Configuration Management(CM;
      
    
    </summary>
    
    
    
      <category term="VCS" scheme="https://poikilo.github.io/tags/VCS/"/>
    
      <category term="software version control" scheme="https://poikilo.github.io/tags/software-version-control/"/>
    
  </entry>
  
  <entry>
    <title>SOLID, KISS, YANGI</title>
    <link href="https://poikilo.github.io/2020/03/02/design-concept/"/>
    <id>https://poikilo.github.io/2020/03/02/design-concept/</id>
    <published>2020-03-02T05:53:59.000Z</published>
    <updated>2020-03-02T21:46:28.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SOLID-객채지향-개발-5대-원리"><a href="#SOLID-객채지향-개발-5대-원리" class="headerlink" title="SOLID : 객채지향 개발 5대 원리."></a>SOLID : 객채지향 개발 5대 원리.</h2><ul><li>SRP(Single Responsibility Principle : 단일 책임의 원칙)<br>작성된 클래스는 하나의 기능만을 가지며, 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어야 한다는 원칙.<br>어떤 변화에 의해 <strong>클래스를 변경해야 하는 이유는 오직 하나여야</strong> 함을 의미한다.</li><li>OCP(Open Close Principle : 개방 폐쇄의 원칙)<br>소프트웨어 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원칙이다.<br>요구사항의 변경이나 추가사항이 발생하더라도, <strong>기존 구성요소는 수정이 일어나지 말아</strong>야 하며, 기존 구성요소를 <strong>쉽게 확장하여 재사용</strong> 할 수 있어야 한다는 것.</li><li>LSP(The Liskov Substitution Principle : 리스코브 치환의 원칙)<br>서브 타입은 언제나 기반타입으로 교체할 수 있어야 한다.(상속과 구현에 대한 내용)<br>서브 클래스가 확장에 대한 인터페이스를 준수해야 한다는 것을 의미한다.</li><li>ISP(Interface Segration Principle : 인터페이스 분리의 원칙)<br>한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리이다. - 최소한의 인터페이스만을 사용한다.</li><li>DIP(Dependency Inversion Principle : 의존성 역전의 원칙)<br>의존 관계의 역전이란, 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전이다.<br>실제 사용관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고 받음으로써, 관계를 최대한 느슨하게 만드는 원칙이다.</li></ul><h2 id="KISS-Keep-It-Simple-Stupid"><a href="#KISS-Keep-It-Simple-Stupid" class="headerlink" title="KISS : Keep It Simple Stupid."></a>KISS : Keep It Simple Stupid.</h2><p>소프트웨어를 설계하는 작업이나, 코딩을 하는 행위에서 되도록이면 간단하고 단순하게 만드는 것이 좋다는 원리이다.(Simple is Best)<br>소스코드나 설계 내용이 불필요하게 장황하거나 복잡해지는 것을 경계하라는 원칙.</p><h2 id="YANGI-You-Ain’t-Gonna-Need-It"><a href="#YANGI-You-Ain’t-Gonna-Need-It" class="headerlink" title="YANGI : You Ain’t Gonna Need It"></a>YANGI : You Ain’t Gonna Need It</h2><p>필요한 작업만을 하라는 의미이다.<br>프로그램을 작성하다보면, 현재는 사용하지 않지만, 확장성을 고려해 미리 작업하는 경우가 많다. :: 이런 행위를 하지말라는 원칙.<br>현재는 사용하지 않는 코드들을 작성하다 보면, 설계와 맞지 않거나 붎릴요하게 장황해지는 코드를 확인할 수 있다.<br>설계나 환경의 변경이 발생되었을 때, 찾기 어렵다. 수정사항도 많아진다…<br>실제 사용 여부를 판단할 수 없어, 전부를 고쳐야하는 상황이 벌어진다..<br>이런 경우를 피하기 위해 사용하지 않는 코드는 작성하지 말자는 원칙!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SOLID-객채지향-개발-5대-원리&quot;&gt;&lt;a href=&quot;#SOLID-객채지향-개발-5대-원리&quot; class=&quot;headerlink&quot; title=&quot;SOLID : 객채지향 개발 5대 원리.&quot;&gt;&lt;/a&gt;SOLID : 객채지향 개발 5대 원리.&lt;/h2
      
    
    </summary>
    
    
    
      <category term="design" scheme="https://poikilo.github.io/tags/design/"/>
    
      <category term="concept" scheme="https://poikilo.github.io/tags/concept/"/>
    
      <category term="software" scheme="https://poikilo.github.io/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>CI(Continuous Integration)</title>
    <link href="https://poikilo.github.io/2020/03/02/ci-server/"/>
    <id>https://poikilo.github.io/2020/03/02/ci-server/</id>
    <published>2020-03-02T05:16:57.000Z</published>
    <updated>2020-03-02T21:46:28.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CI-Continuous-Integration-지속적-통합"><a href="#CI-Continuous-Integration-지속적-통합" class="headerlink" title="CI(Continuous Integration) : 지속적 통합"></a>CI(Continuous Integration) : 지속적 통합</h2><ul><li>소프트웨어 공학에서 CI(;지속적 통합)이란, 모든 개발자의 작업 산출물을 하루에 여러번 통합(Merge)하는 작업을 의미한다.</li><li>XP(Extream Programming) 방법론에서는 CI의 컨셉을 적용하여 하루에 수십번 통합하는 작업을 진행한다.</li></ul><h2 id="Common-Practice-일반적-관행"><a href="#Common-Practice-일반적-관행" class="headerlink" title="Common Practice : 일반적 관행"></a>Common Practice : 일반적 관행</h2><ul><li><p>Maintain a code Repository<br>소스 코드 저장소를 유지관리하는 것을 의미한다. : version control.</p></li><li><p>Automated Build<br>자동 compile -&gt; linking -&gt; build 과정을 거쳐 최종 배포될 산출물을 만드는 것을 의미한다. : build automation</p></li><li><p>Make the build self-testing<br>코드가 빌드되면, 모든 테스트는 개발자가 의도한대로 동작하는지 테스트를 수행해야 한다. : Unit Test(기능단위 테스트), Integration Test(통합테스트), Static Analysis(정적분석; 코드 품질관리)</p></li><li><p>Everyone commits to the base line every day<br>정기적인 commit을 하는 것은, 모든 committer가 변경사항의 충돌을 줄일 수 있다. 1주간의 업무점검은 해결하기 어려운 다른 형상과의 충돌위험을 줄일 수 있다.<br>일찍이, 사소한 충돌이 발생하는 것은 팀 멤버들이 자신들이 만드는 것의 변화에 대해 소통하게 한다.<br>적어도 하루에 한번모든 변경사항을 commit 하는 것은 CI의 정의 중 한 부분으로 간주된다.<br>일반적으로, 새벽에 빌드하는 것이 추천된다.</p></li><li><p>Every Commit to Baseline shuld be built<br>시스템은 커밋된 사항들이 통합된 것(시스템 자체)을 검증하기 위해 현재의 버전에 커밋된 사항을 빌드해야 한다.<br>일반적 관행으로 자동 CI를 사용한다.(몇몇은 수동으로 진행할 수 있다.)<br>CI 자동화 시스템은 지속적인 통합서버(CI Server) 또는 데몬을 사용하여 변경 관리 시스템(revision control system) 을 모니터링 하고, 빌드 프로세스를 자동으로 실행한다.</p></li><li><p>Keep the build fast<br>빌드는 빠르게 완료될 필요가 있다. 통합에 문제가 발생하면 빠르게 감지되어야 한다.</p></li><li><p>Test in a clone of the production environment<br>운영 환경과 테스트 환경이 다르기 때문에, 테스트 된 시스템이더라도 운영환경에서 error가 발생할 수 있다.<br>운영환경을 똑같이 복제한 환경을 구축하는 것은 비용이 많이 든다.<br>테스트 환경 대신 pre-production(simulation) 환경을 구축한다.<br>pre-production 환경은 기술스택 구성을 유지하면서 비용을 절감할 수 있다.<br>이러한 테스트 환경에서 서비스 가상화는 의존형에 대한 on-demand access를 얻는데 일반적으로 사용한다.</p></li><li><p>Make it easy to get the latest deliverable<br>시스템 이해 관계자와 테스터가 쉽게 사용할 수 있는 빌드 도구를 만들면, 요구사항을 충족하지 않는 기능을 다시 빌드할 때 필요한 재 작업의 양을 줄일 수 있다.<br>추가적으로 앞선 테스팅은 배포되기까지 남아있는 결함을 줄일 수 있는 기회를 준다.<br>에러를 빠르게 감지하는 것은 그 에러를 해결하는데 필요한 작업의 양을 줄일 수 있다.</p></li><li><p>Everyone can see the result of the latest build<br>모든 사람이 최신의 빌드 결과를 확인할 수 있다.<br>이는 빌드의 중단점을 찾기 쉽게 도와주며, 빌드가 중단되었다면 어떤 변화가 중단을 일으켰는지, 중단의 원인이 되는 변경사항을 개발한 사람은 누구인지 확인할 수 있게 한다.</p></li><li><p>Automate deployment<br>대부분의 CI 시스템은, 빌드가 종료되는 순간 script를 수행할 수 있는 기능을 제공한다.<br>대부분의 경우 운영중인 테스트 서버(모든 사람이 볼 수 있는)에 application을 배포하는 스크립트를 작성한다.<br>이러한 사고방식의 발전으로 지속적인 배포가 등장하게 되고, 지속적인 배포에는 소프트웨어를 운영환경에 직접 배포하고 결함 또는 회귀를 방지하기 위한 추가 자동화가 필요하다.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CI-Continuous-Integration-지속적-통합&quot;&gt;&lt;a href=&quot;#CI-Continuous-Integration-지속적-통합&quot; class=&quot;headerlink&quot; title=&quot;CI(Continuous Integration) :
      
    
    </summary>
    
    
    
      <category term="CI" scheme="https://poikilo.github.io/tags/CI/"/>
    
      <category term="S/E" scheme="https://poikilo.github.io/tags/S-E/"/>
    
      <category term="software engineering" scheme="https://poikilo.github.io/tags/software-engineering/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes#1 용어정리</title>
    <link href="https://poikilo.github.io/2020/02/27/kubernetes-1/"/>
    <id>https://poikilo.github.io/2020/02/27/kubernetes-1/</id>
    <published>2020-02-27T07:21:00.000Z</published>
    <updated>2020-03-02T21:46:28.916Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Kubernetes-용어-정리"><a href="#Kubernetes-용어-정리" class="headerlink" title="Kubernetes 용어 정리"></a>Kubernetes 용어 정리</h4><table><thead><tr><th>Term</th><th>Description</th><th>etc</th></tr></thead><tbody><tr><td>Cluster</td><td>여러 대의 서버(Node)를 묶어, 하나의 자원처럼 사용하는 것.<br><br></td><td></td></tr><tr><td>Node</td><td>클러스터 구성의 기본 단위. 물리서버 1대가 될 수도 있고, Openstack VM Instance 한대가 될 수도 있다.<br><br></td><td></td></tr><tr><td>Master-Node</td><td>Kubernetes의 System Operator 역할, coordinator 역할을 수행하는 Pod들이 올라가 있는 곳.<br>Pod의 Scheduling, Metric 계산(matric-server), Tiller, Dashboard 등이 올라갈 수 있다.<br>kubernetes api 자원관리, 네트워크관리, api 등 kubernetes의 시스템적인 운영을 담당하는 노드이다.<br><br></td><td></td></tr><tr><td>Worker-Node</td><td>사용자가 배포하는 application, service가 동작하는 노드이다.<br><br></td><td></td></tr><tr><td>CRE</td><td>Container Runtime Environment<br>- 컨테이너를 구동하는 환경을 의미한다. <br>- 대표적 예로, Docker와 Container.d가 있다.<br><br></td><td></td></tr><tr><td>Container</td><td>CRE에서 동작하는 단위<br>Virtual Machine과 다르게, Host의 OS, Kernel의 자원을 공유한다.<br>때문에 더 가볍다는 의견.<br><br></td><td></td></tr><tr><td>Pod</td><td>Container를 1개이상 포함하는, Kubernetes의 서비스 최소단위.<br><br></td><td></td></tr><tr><td>Service</td><td>CRE에서 제공하는 내부 네트워크 ip 대역을 추상화 한 개념이다.<br>실제로 사용자는 어떻게 container가 생성되었고, 어떤 내부 ip를 할당받았는지 알수 없기 때문에 kubernetes에서는 Service라는 개념을 도입.<br>Service 명을 통해 Pod에 접속 또는 연결(Connect)하게 된다.<br><strong>Service는 해당 Pod들에 외부/내부에서 접속하기 위한 IP, Port를 설정</strong> 할 수 있다.<br>Service는 <strong>Pod와 연결하기 위해 Label Selector</strong> 라는 개념을 사용한다.<br>Pod의 Metadata에 Label을 기재하도록 하는데, 이를 통해 서비스와 연결한다.<br> (HTML의 Query Selector, JQuery의 Class select 방식을 생각하면 좀 더 이해하기 쉽다.)<br><br></td><td></td></tr><tr><td>Ingress</td><td>ingress는 도메인, path를 통해 어떤 서비스와 연결할지 설정이 가능하다.<br>e.g., domain *.mypage.com 에 대해 backend는 서비스명 homepage-service<br>path는 “/“에 대해 *.mypage.com/ 으로 접속하면 homepage-service와 연결<br>ServicePort는 80 http프로토콜 접속을 허용한다는 것.<br> <strong>외부에서 도메인틀 통한 접속 -&gt; ingress 설정을 확인하여 해당하는 서비스와 연결 -&gt; 해당 서비스에 매핑되어있는 Pod에 연결</strong> <br><br></td><td></td></tr><tr><td>Replica Set</td><td>Single point failure를 제어하기 위한 개념.<br>Pod의 수를 제어한다.<br>Replica Set, Replica Controller는 Pod의 수를 제어한다. 실제 running중인 Pod의 수가 ReplicaSet에 기재된 replica count보다 작다면, Deployment에 기재된 Pod의 template를 참조하여 Pod를 추가로 생성한다.<br><br></td><td></td></tr><tr><td>Stateful Set</td><td>컨테이너가 제거 또는 재시작 되어도, <strong>상태의 영속성</strong> 을 보장해야 하는 워크로드에 사용된다.<br>e.g., Database Nginx 등<br><br></td><td></td></tr><tr><td>Daemon Set</td><td>솔루션의 모니터링, 로깅 등을 다른 App의 구동과는 무관하게 지속적으로 실행되어야 하는 app을 위해 사용한다.<br><br></td><td></td></tr><tr><td>Deployment</td><td>Replica Set과 Pod를 정의할 수 있도록 추상화 한 개념<br>Deployment를 kuberctl apply를 통해 적용하면, Deployment, Replica Set, Pod가 생성된다. <br>Deployment를 삭제하더라도, ReplicatSet이 남아있다면 Pod는 삭제되지 않는다.<br>Deployment, ReplicaSet을 모두 제거해야만 Pod가 삭제된다.<br><br></td><td></td></tr></tbody></table><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;www.draw.io\&quot; modified=\&quot;2020-02-19T03:54:52.703Z\&quot; agent=\&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36\&quot; etag=\&quot;e54n-G_G8oxnpoMZRh6N\&quot; version=\&quot;12.7.1\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;4Cl5Zr4XpdmF6iXK8EqK\&quot; name=\&quot;Page-1\&quot;&gt;7Vpbc5s4GP01fkwGEJLFY+pkd/PQTmb9kPapI8PHZRZbrpBv++srQGDA6m7acvEkIXlAR+KTpXOO0Hxihhbr45+CbeOPPIB05ljBcYbuZ45ju44zy/+t4FQijkXsEolEEuhWZ2CZ/AsatDS6SwLIWg0l56lMtm3Q55sN+LKFMSH4od0s5Gm71y2L4AJY+iy9RJ+TQMYlSp35Gf8LkiiueraJV9asWdVYjySLWcAPDQg9zNBCcC7Lu/VxAWk+e9W8lM/98YPa+ocJ2MiXPHD3+fHLVxY97j/snIh7z8+bjzc3OsqepTs94JlDUhXvw0rdRPlNBYRc9aOGIU96bsi3Ha8qbrKCuTvVwPa2x3NlFWWR7jIJoo4uuuHfkakQJZmS2wu4oQGnRb0j+G4TQK4sW1Uf4kTCcsv8vPagVgKFxXKd6uowSdMFT7konkW+DzgMFZ5Jwf+BRg0iyENB3d8ehITjD+Vu1yZSyw/wNUhxUk30A0jbTi88Ntblw9nFc09jccPBuPIr0ytHVIc+m0vdaH/9hNecAbw2N3ntk1qGr0NabxkZ21ZQXEPbym3bqn5PN2zlYIOtXDyUrfAAtqImW93DNuWnNRScXoHArlGEYRg6vm8SYUBWBJN+RIjbInRNIkQGEdbq7V2EZKy1/W8lwsRnS5CTUYzzPxPFpLj0SJrrT3H1Qz3pUE8N1NsG6slQzM8HYJ6YmH/iwWSvFjvAMDdR7pE5Yj252mtTi007tjGZpe/M9sSs3dmMYzIxtd5rpDZgWVy37YE1x7oy1qp1ffi37BLEPvFhKlcqT9LANbmSOitEenJl51WK3KlfpfYQ2Sgjv4+bSECWTcYvAxoad8nEp7AKB+HXMdh3ZH7fMyBvCnmdGRDc9dX0KRAbvRvrLSGv01jIuj5juQMYy3g+9nCUIDYs/0V3vv+bexM1smSbFYTFbJuDfsp3wU/zvrIAATHxbgG1KO2Hd9tu835j2Khg01GNPdxOxZRU7k7yJrjLD5iL2WVZlpQbOibkJdyY4jIOBBfHzp3pUn3xnfDhBftl1WcE8n9lfElAc4JNR2EaE5AymezbP9g057qHJ54UVjCfxM27SdhynPqhM3EXcWg7DvE6ccppuIhTCKAe9G9owpTj7UcTcEzkZ3Vv3WJd+lKUaJE1zcv3+RxYVeHUKDyBSNTQQGjspfqaSg02cW9pi0iEvVuP/pomDNGskWVhSgBf3VJBp6Z87jUu3GLMRYp/79f5/4/QiFq3lj2uHkxp43H1MBXP9adOVcKw+ynFS1ntvjIwHdnTrz8/PMk5wIgZZVU8f1pX6uL8hSJ6+A4=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://www.draw.io/js/viewer.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Kubernetes-용어-정리&quot;&gt;&lt;a href=&quot;#Kubernetes-용어-정리&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes 용어 정리&quot;&gt;&lt;/a&gt;Kubernetes 용어 정리&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="kubernetes" scheme="https://poikilo.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Github 블로그 생성</title>
    <link href="https://poikilo.github.io/2020/02/26/first-post/"/>
    <id>https://poikilo.github.io/2020/02/26/first-post/</id>
    <published>2020-02-26T01:42:44.000Z</published>
    <updated>2020-03-02T21:46:28.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="기술블로그-Start"><a href="#기술블로그-Start" class="headerlink" title="기술블로그 Start"></a>기술블로그 Start</h3><hr><p>2020-02-26 3번째 회사의 퇴사를 앞두고, 보안사항이 아닌 개발관련 정리내용을 옮기기로 결심.<br>Confluence의 개인 공간에 작성해 두었던 기술관련 정리내용들을 옮겨보려 했다.</p><h3 id="hexo를-선택하게-된-이유"><a href="#hexo를-선택하게-된-이유" class="headerlink" title="hexo를 선택하게 된 이유"></a>hexo를 선택하게 된 이유</h3><hr><p>github 블로그를 생성하는 개발자에게 인기가 많은 프레임워크는 아래 3종이 있다.  </p><ul><li>jekyll<ul><li>가장 많은 사용자를 보유하고 있다.<ul><li>한글 사용법, 다양한 테마 지원 등의 강점이 있다.</li></ul></li><li>ruby 기반의 프레임워크이다.<ul><li>이부분이 나한테는 단점으로 다가왔다.</li></ul></li></ul></li><li>Hexo<ul><li>nodejs 기반의 프레임워크이다.<ul><li>node-express를 사용해본 사람이라면, ejs 문법도 그렇게 어렵지 않다.</li><li>kubernetes, helm, gitlab을 사용해본 경험으로 YAML configuration 문법이 좀 더 쉽게 다가왔다.</li></ul></li><li>기본 테마, 깔끔한 템플릿은 많이 있다.</li><li>git으로 포스트 버전관리가 안된다.<ul><li>별도 포스트 버전관리를 위한 저장소를 지정하고</li><li>배포를 지원하는 hexo-deployer-git node package를 사용하여 포스팅 하기로 결정했다.</li></ul></li></ul></li><li>Hugo<ul><li>go lang 기반으로 만들어졌으며, 빠르다는 강점이 있다.<ul><li>필자는 jekyll과 hexo만 사용해봤으며, 좀 더 쉽게 configuration 할 수 있는 hexo를 선택하게 되었다.</li></ul></li></ul></li></ul><h3 id="clean-blog-theme-를-선택하게-된-이유"><a href="#clean-blog-theme-를-선택하게-된-이유" class="headerlink" title="clean-blog theme 를 선택하게 된 이유"></a>clean-blog theme 를 선택하게 된 이유</h3><hr><p>크게 다른이유는 없다..<br>cresumerjang님 블로그를 참고하여, 진행하다보니<br>comment, discussion 하는 library(disqus)를 사용하기 위해 선택하게 되었다.</p><h3 id="HEXO-블로그-입문-참고-첫-블로그-포스팅"><a href="#HEXO-블로그-입문-참고-첫-블로그-포스팅" class="headerlink" title="HEXO 블로그 입문 참고 - 첫 블로그 포스팅."></a>HEXO 블로그 입문 참고 - 첫 블로그 포스팅.</h3><hr><p><a href="https://cresumerjang.github.io/2019/01/17/hexo-start-manual/" target="_blank" rel="noopener">cresumerjang님 블로그 :: hexo 블로그 입문 가이드</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;기술블로그-Start&quot;&gt;&lt;a href=&quot;#기술블로그-Start&quot; class=&quot;headerlink&quot; title=&quot;기술블로그 Start&quot;&gt;&lt;/a&gt;기술블로그 Start&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;2020-02-26 3번째 회사의 퇴사를 앞두고, 보
      
    
    </summary>
    
    
    
      <category term="blog" scheme="https://poikilo.github.io/tags/blog/"/>
    
      <category term="begineer" scheme="https://poikilo.github.io/tags/begineer/"/>
    
  </entry>
  
</feed>
