<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MMM</title>
  
  <subtitle>WWW를 뒤집어보기</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://poikilo.github.io/"/>
  <updated>2020-03-05T12:18:13.087Z</updated>
  <id>https://poikilo.github.io/</id>
  
  <author>
    <name>Yonghyun Kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Google Home Mini</title>
    <link href="https://poikilo.github.io/2020/03/05/daily-1/"/>
    <id>https://poikilo.github.io/2020/03/05/daily-1/</id>
    <published>2020-03-05T11:58:30.000Z</published>
    <updated>2020-03-05T12:18:13.087Z</updated>
    
    <content type="html"><![CDATA[<p>2020-03-05<br>Youtube Premium 프로모션으로 구글 홈 미니를 신청할 수 있었다. - 2020-03-03<br>2월달 말에 시작된 프로모션이지만, 재고부족으로 신청할 수 없었는데.. 😂😂  </p><p>3월 3일 아침에 재고가 나와서, 빠르게 신청!<br><img src="https://user-images.githubusercontent.com/61483036/75980088-2d7fcb80-5f25-11ea-9233-29db6ee1023f.png" alt="구글 홈 미니 신청">  </p><p>결과는 현재 배송중이다..<br><img src="https://user-images.githubusercontent.com/61483036/75979719-71260580-5f24-11ea-9b7c-d44e033bc10d.png" alt="구글 홈 미니">  </p><p>각 단계별로 이메일로 상태를 알려줘서 바로바로 확인이 가능했다..<br>실제 배송중 메일의 경우 택배 배송조회 링크가 포함되어있는데,<br>링크가 깨져있다. 아래 링크에서 운송장 번호로 조회 할 수 있다.💁‍♂️<br><a href="https://www.lotteglogis.com/home/reservation/tracking/index" target="_blank" rel="noopener">롯데글로벌로지스 택배조회</a>  </p><p>배송완료시, 리뷰형식으로 한번 적어보도록 하자..👏👏  </p><p>애플 생태계에 들어온지 2년차.. 구글 어시스턴스로 사용할일은 없을 것 같지만, 집안에 스피커로 사용하면 좋을 듯 보인다.  </p><p>코로나 19의 여파로 마스크 구하기는 진짜 하늘에 별따기로..<br>온라인 구매는.. 전국민과 함께하는 수강신청 같은 느낌이라 매번 실패하고 있다.. ㅠ_ㅠ<br>마스크 5부제 적용으로, 주말 부터 약국에서 2매 구할 수 있을 것 같으니!<br>잘 참고해서 가시길 바란다.  </p><p>6~8일 까지 약국에서는,<br>인당 2매를 구매할 수 있으나, 마스크 5부제 적용으로 구매할 수 있는 요일과 출생년도 끝자리는 아래와 같다.  </p><p>월요일 : 1, 6 년생<br>화요일 : 2, 7 년생<br>수요일 : 3, 8 년생<br>목요일 : 4, 9 년생<br>금요일 : 5, 0 년생<br>주말 : 년도 상관없이 주일에 구매하지 못한 국민을 위한다.  </p><p>개인의 사재기 방지를 위한 중복 구매 제한은 차주부터 실시한다.  </p><p>우체국과 하나로마트에선, 중복 구매 방지 시스템 도입이 늦어져, 개인당 1매 구매로 실시한다.<br>중복구매 방지 시스템 도입 이후로는 약국과 동일하게 판매 진행하니 잘 챙겨서 어려움을 극복하자 !  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020-03-05&lt;br&gt;Youtube Premium 프로모션으로 구글 홈 미니를 신청할 수 있었다. - 2020-03-03&lt;br&gt;2월달 말에 시작된 프로모션이지만, 재고부족으로 신청할 수 없었는데.. 😂😂  &lt;/p&gt;
&lt;p&gt;3월 3일 아침에 
      
    
    </summary>
    
    
    
      <category term="youtube" scheme="https://poikilo.github.io/tags/youtube/"/>
    
      <category term="premium" scheme="https://poikilo.github.io/tags/premium/"/>
    
      <category term="promotion" scheme="https://poikilo.github.io/tags/promotion/"/>
    
      <category term="google" scheme="https://poikilo.github.io/tags/google/"/>
    
      <category term="daily" scheme="https://poikilo.github.io/tags/daily/"/>
    
      <category term="diary" scheme="https://poikilo.github.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>배포전략(Deployment Strategy)</title>
    <link href="https://poikilo.github.io/2020/03/03/deployment-strategy/"/>
    <id>https://poikilo.github.io/2020/03/03/deployment-strategy/</id>
    <published>2020-03-03T09:25:08.000Z</published>
    <updated>2020-03-05T12:02:09.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="배포-전략"><a href="#배포-전략" class="headerlink" title="배포 전략"></a>배포 전략</h2><hr><h3 id="Blue-Green-Deployment"><a href="#Blue-Green-Deployment" class="headerlink" title="Blue/Green Deployment"></a>Blue/Green Deployment</h3><p>Blue/Green 배포 전략은 새 버전의 서버 그룹을 모두 배포 완료한 뒤에,<br>로드밸런서에서 트래픽을 구 버전에서 새 버전으로 일시에 바꾸는 방식이다.  </p><ul><li>장점<ul><li>Downtime 최소화 가능</li><li>신규 버전에 문제 발생시 빠른 rollback이 가능하다.</li></ul></li><li>단점<ul><li>인프라 리소스가 2배로 들어간다.</li><li>기존 운영되고 있는 서버에서 Long-term 트랜잭션이 수행중이었다면 전환시 어떤 방식으로 처리할 지 충분한 고려가 필요하다.</li><li>두 서버 환경간 migration이 배포때 마다 필요하며, Rollback 수행시에도 고려해야 한다.<br><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--fJ4tYKdy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/78dk41w8qmuy9f9pvrf6.png" alt="bluegreen_1"><br><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ca9C-wVZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/m664yyotixnqncprryf0.png" alt="bluegreen_2">  </li></ul></li></ul><h3 id="Rolling-Update-Deployment"><a href="#Rolling-Update-Deployment" class="headerlink" title="Rolling Update Deployment"></a>Rolling Update Deployment</h3><p>롤링 업데이트 방식은, 새 버전의 서버를 만들어가면서 트래픽을 구 버전 서버에서 신 버전 서버로 점차적으로 옮기는 형태이다.<br>구 버전 서버와 신 버전 서버의 비율을 N-K : K (K를 N까지 증가)로 조정하며 점차적으로 부하를 신 버전 서버로 이전하는 방식이다.<br>Blue/Green 배포 방식은 인프라 리소스가 2배로 필요한데 비해, 롤링 업데이트 배포는 서버 자원이 한정적인 경우 유리하다.  </p><ul><li>장점<ul><li>Downtime이 없음.</li><li>버전의 업데이트와 테스팅을 동시에 수행할 수 있다.</li></ul></li><li>단점<ul><li>구 버전과 신 버전이 공존하는 시기가 있으므로, 두 버전을 모두 고려하여 개발해야 한다.(e.g., DB schema)</li><li>세션 영속성에 대한 고려사항(서버가 롤링 업데이트 상태로 넘어갈 때, 기존 서버에 접속하고 있던 사용자의 session을 신규 서버로 이전해야 한다. 업데이트가 종료된 서버나 업데이트 되지 않은 서버 모두에서 서비스를 이어갈 수 있도록 구성해야 한다.)<br><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--RbA0NHA6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/divuxihkun2p186c9mye.png" alt="rollingupdate"></li></ul></li></ul><h3 id="Canary-Deployment"><a href="#Canary-Deployment" class="headerlink" title="Canary Deployment"></a>Canary Deployment</h3><blockquote><p><strong>카나리 테스트</strong><br>옛날, 광부들이 광산에서 유독가스가 나오는 것을 알아내기 위해 가스에 민감한 카나리아를 광산안에 키웠다고 한다.<br>카나리아가 죽으면 유독가스가 나오는 것으로 판단하고 조치를 취했다고 하는데, 이 개념을 개발에서 사용하는 것이 카나리 테스트 방식이다.</p></blockquote><p>카나리 배포는 일부서버(10% 정도?)에만 신 버전을 배포하여 운영한 후 문제가 없는것이 확인되면 점차적으로 모든 서버에 신 버전을 배포하는 방식이다.  </p><ul><li>장점<ul><li>capacity testing을 운영환경에서 진행할 수 있다는 점.(Rollback도 간단하게 가능하다.)</li></ul></li><li>단점<ul><li>동시에 여러개의 소프트웨어 버전을 관리해야 한다는 점.</li><li>동시에 2개 이상의 버전이 운영환경에 배포되도록 할 수 있겠지만, 좋은 방법이 아니다..(롤백만 생각해도..)</li><li>사용자 PC나 모바일 기기에 설치하는 경우에도 사용이 어렵다.(사용자(고객)를 제한할 수 없다.)<br><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--7PmOiuG9--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/zvf9rbd1x38umph98zro.png" alt="canary"></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;배포-전략&quot;&gt;&lt;a href=&quot;#배포-전략&quot; class=&quot;headerlink&quot; title=&quot;배포 전략&quot;&gt;&lt;/a&gt;배포 전략&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;Blue-Green-Deployment&quot;&gt;&lt;a href=&quot;#Blue-Green-Depl
      
    
    </summary>
    
    
    
      <category term="deployment" scheme="https://poikilo.github.io/tags/deployment/"/>
    
      <category term="deploy" scheme="https://poikilo.github.io/tags/deploy/"/>
    
      <category term="CD" scheme="https://poikilo.github.io/tags/CD/"/>
    
      <category term="continuous delivery" scheme="https://poikilo.github.io/tags/continuous-delivery/"/>
    
      <category term="continuous deploy" scheme="https://poikilo.github.io/tags/continuous-deploy/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API</title>
    <link href="https://poikilo.github.io/2020/03/03/RESTful-api/"/>
    <id>https://poikilo.github.io/2020/03/03/RESTful-api/</id>
    <published>2020-03-03T09:12:44.000Z</published>
    <updated>2020-03-05T12:02:09.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h2><p>REST : Representational State Transfer의 약자<br>자원(Resource)을 이름(자원의 표현(represent))으로 구분하여, 해당 자원의 상태(정보)를 주고받는 모든 것을 의미한다.<br>HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE, PATCH 등)를 통해 해당 자원에 대한 CRUD(Create, Read, Update, Delete) Operation을 적용하는 것을 의미한다.  </p><h2 id="장-단점"><a href="#장-단점" class="headerlink" title="장/단점"></a>장/단점</h2><ul><li>장점<br>HTTP 프로토콜의 인프라를 그대로 사용하므로, REST API 사용을 위한 별도의 인프라를 구축할 필요가 없다.<br>HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다.<br>HTTP 표준 프로토콜을 따르는 모든 플랫폼에서 사용 가능하다.<br>Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.<br>REST API 메시지가 의도하는 바를 명확하게 나타내므로, 의도하는 바를 쉽게 파악할 수 있다.(e.g.,DELETE - 삭제, GET - 조회)<br>여러가지 서비스 디자인에서 생길 수 있는 문제를 최소화 한다.<br>서버와 클라이언트의 역할을 명확하게 분리한다.  </li><li>단점<br>표준이 존재하지 않는다.(사용하는 주체에 따라, POST를 update, PATCH를 update 로 쓰는 경우가 있더라..)<br>사용할 수 있는 HTTP Method가 4가지 밖에 없다.(보안상의 이슈로 사용할 수 있는 HTTP Method에 제약을 두더라, 확실치는 않다.)<br>브라우저를 통해 테스트 할 일이 많은 서비스라면, 쉽게 고칠 수 있는 URL 보다 Header 값이 더 어렵게 느껴진다. (GET 방식의 query string이 좀 더 편하게 다가올 수 있다..)<br>구형 브라우저에서 제대로 지원하지 못하는 부분이 존재한다.(PUT, DELETE를 사용하지 못하는 점 등.)  </li></ul><h2 id="RESTful-API-설계-기본-규칙"><a href="#RESTful-API-설계-기본-규칙" class="headerlink" title="RESTful API 설계 기본 규칙"></a>RESTful API 설계 기본 규칙</h2><ul><li><p>용어</p><ul><li>document : 객체 인스턴스나 데이터베이스의 레코드와 유사한 개념.</li><li>collection : 서버에서 관리하는 directory 리소스(폴더)</li><li>store : 클라이언트에서 관리하는 리소스 저장소.</li></ul></li><li><p>URI는 자원을 표현해야 한다.</p><ul><li>resource는 동사보다는 명사를, 대문자보다는 소문자를 사용한다.</li><li>resource의 도큐먼트 이름으로는 단수명사를 사용해야 한다.</li><li>resource의 컬렉션 이름으로는 복수명사를 사용해야 한다.</li><li>resource의 스토어 이름으로는 복수명사를 사용해야 한다.</li></ul></li><li><p>자원에 대한 행위는 HTTP Method(GET, PUT, POST, DELETE 등)로 표현한다.</p><ul><li>URI에 HTTP Method가 들어가면 안된다.</li><li>URI에 행위에 대한 동사표현이 들어가면 안된다.</li><li>경로 부분 중, 변하는 부분은 유일한 값으로 대체한다. (자원을 구분할 수 있는 Key)</li></ul></li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Web 개발을 하다보면, CRUD는 엄청많이 만들어본다. Database에 Table이 신규로 추가되면 엄청 많이 만든다. insert, select, update, delete..<br>내가 개발하고 있는 시스템에서 관리하는 자원(데이터, 파일 등)을 Interface로 주고 받는 일은 이전 개발중에도 많이있었고<br>그 방법으로,<br>DB to DB (A시스템에서 B시스템 Database 서버에 접속하여 데이터를 가져가는 방법)<br>EAI (DB to DB 방식으로 했을때의 단점이 너무 많아서, DB 이전 등, 회사의 Database Interface를 관리하는 EAI를 이용하는 방식.)<br>API (시스템에서 API로 개발하고, Spec을 전달하여 타 시스템에서 데이터를 가져가는 정도..)<br>뭐 더 많을 것이다. NAS에 같은 위치에 파일을 쓴다던지..  </p><p>RESTful API의 장점이라고 생각하는건  </p><p>자원을 classify 하기 쉽다는점.(URI에 directory구조로 들어가는데, 자원의 상위 그룹을 알수 있다.) – 서버단에 폴더 구조도 깔끔해진다.  </p><p>CRUD에 대한 Method를 어렵게 만들필요가 없다는점. → Node로 개발 해 봤는데, 같은 URI 주소에 대해 GET, POST, PUT, DELETE 로 날리기가 엄청 편하다..  </p><ol><li><p>특정 자원이 필요하면, 그 자원을 식별할수 있는 주소를 만든다. e.g., mailbox/u/1/ → mail box에 사용자(user) 1번  </p></li><li><p>해당 자원에 대해 CRUD는 Method를 다르게 만드는것이 아니라.. HTTP Method를 이용하여 만든다.  </p></li></ol><p>URI에서 의미하는것이 직관적으로 나타나는게 좋고, 행위가 들어가는게 아니라서 getUserMail ← 이런식의 URL은 없어도 된다는게 좋았던것 같다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;정의&quot;&gt;&lt;a href=&quot;#정의&quot; class=&quot;headerlink&quot; title=&quot;정의&quot;&gt;&lt;/a&gt;정의&lt;/h2&gt;&lt;p&gt;REST : Representational State Transfer의 약자&lt;br&gt;자원(Resource)을 이름(자원의 표현(
      
    
    </summary>
    
    
    
      <category term="api" scheme="https://poikilo.github.io/tags/api/"/>
    
      <category term="restful" scheme="https://poikilo.github.io/tags/restful/"/>
    
      <category term="rest" scheme="https://poikilo.github.io/tags/rest/"/>
    
  </entry>
  
  <entry>
    <title>Git 저장소 empty 폴더 관리</title>
    <link href="https://poikilo.github.io/2020/03/03/gitkeep-cleaner/"/>
    <id>https://poikilo.github.io/2020/03/03/gitkeep-cleaner/</id>
    <published>2020-03-03T05:07:47.000Z</published>
    <updated>2020-03-05T12:02:09.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>git을 사용하다보면, 폴더만 생성되었거나 폴더 하위의 파일이 없는 경우 stage에 올릴 수 없다.(commit, push 불 가능)<br>때문에 .gitkeep 파일을 생성하여 해당 경로를 공유한다.<br>만약, 폴더 내 파일이 생성되는 경우 .gitkeep의 불필요한 파일은 삭제해 주는 것이 좋다.  </p><h2 id="작업"><a href="#작업" class="headerlink" title="작업"></a>작업</h2><ul><li>Main.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package fileMaker;</span><br><span class="line"> </span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        if(args.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            System.out.println(&quot;경로를 입력해 주세요.&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;##########################################&quot;);</span><br><span class="line">            System.out.println(&quot;######## Directory Keeper Starts!!! ######&quot;);</span><br><span class="line">            System.out.println(&quot;##########################################&quot;);</span><br><span class="line">             </span><br><span class="line">            System.out.println(&quot;INPUT DIR : &quot;+ args[0]);</span><br><span class="line">             </span><br><span class="line">            FileManager fileManager &#x3D; new FileManager();</span><br><span class="line">            try &#123;</span><br><span class="line">                fileManager.filePathTravel(args[0]);</span><br><span class="line">            &#125;catch(IOException ie) &#123;</span><br><span class="line">                System.out.println(&quot;파일 I&#x2F;O 문제 발생!!&quot;);</span><br><span class="line">                ie.printStackTrace();</span><br><span class="line">            &#125;catch(Exception e) &#123;</span><br><span class="line">                System.out.println(&quot;Exception 발생 !!&quot;);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>FileManager.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">package fileMaker;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">public class FileManager &#123;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    public void filePathTravel(String source) throws IOException &#123;</span><br><span class="line">        File dir &#x3D; new File(source);</span><br><span class="line">         </span><br><span class="line">        File[] fileList &#x3D; dir.listFiles();</span><br><span class="line">         </span><br><span class="line">        if(fileList.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            makeGitKeep(source);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            removeKeepFiles(source);</span><br><span class="line">             </span><br><span class="line">            for(int i&#x3D;0; i&lt;fileList.length; i++) &#123;</span><br><span class="line">                File file &#x3D; fileList[i];</span><br><span class="line">                 </span><br><span class="line">                if(file.isDirectory()) &#123;</span><br><span class="line">                    filePathTravel(file.getCanonicalPath().toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param directory</span><br><span class="line">     * @description 전달받은 경로에 .gitkeep 파일 생성.</span><br><span class="line">     * @return 파일 생성 여부.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean makeGitKeep(String directory) throws IOException &#123;</span><br><span class="line">        String fileName &#x3D; &quot;.gitkeep&quot;;</span><br><span class="line">         </span><br><span class="line">        File f &#x3D; new File(directory + File.separator + fileName);</span><br><span class="line">         </span><br><span class="line">        return f.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public boolean removeKeepFiles(String directory) throws IOException&#123;</span><br><span class="line">        File dir &#x3D; new File(directory);</span><br><span class="line">        File[] fileList &#x3D; dir.listFiles();</span><br><span class="line">        ArrayList&lt;String&gt; removeFileNames &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        &#x2F;&#x2F; 불필요한 파일 목록</span><br><span class="line">        removeFileNames.add(&quot;.gitkeep&quot;);</span><br><span class="line">        removeFileNames.add(&quot;deleteme.txt&quot;);</span><br><span class="line">         </span><br><span class="line">        int fileCount &#x3D; 0;</span><br><span class="line">        int folderCount &#x3D; 0;</span><br><span class="line">         </span><br><span class="line">        for(int i&#x3D;0; i&lt;fileList.length; i++) &#123;</span><br><span class="line">            File tmp &#x3D; fileList[i];</span><br><span class="line">             </span><br><span class="line">            if( tmp.isFile() ) &#123;</span><br><span class="line">                if( !removeFileNames.get(0).equalsIgnoreCase(tmp.getName()) &amp;&amp; !removeFileNames.get(1).equalsIgnoreCase(tmp.getName()) ) &#123;</span><br><span class="line">                    fileCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if( tmp.isDirectory() ) &#123;</span><br><span class="line">                folderCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        if( (fileCount &gt; 0) || (fileCount &#x3D;&#x3D; 0 &amp;&amp; folderCount &gt; 0 ) ) &#123;</span><br><span class="line">            File gitKeepFile &#x3D; new File(directory + File.separator + removeFileNames.get(0));</span><br><span class="line">            File deletemeFile &#x3D; new File(directory + File.separator + removeFileNames.get(1));</span><br><span class="line">             </span><br><span class="line">            if(gitKeepFile.exists()) &#123;</span><br><span class="line">                if(!gitKeepFile.delete()) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(deletemeFile.exists()) &#123;</span><br><span class="line">                if(!deletemeFile.delete()) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><p>executable jar로 export<br>필자의 경우 EmptyFolder.jar로 파일명을 정했다.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar EmptyFolder.jar &#123;repository_path&#125;</span><br></pre></td></tr></table></figure><p>비어있는 폴더의 경우 .gitkeep 파일을 생성한다.<br>비어있지 않은 폴더에서 .gitkeep이나 deleteme.txt 등 불필요한 파일이 존재하면 삭제한다.  </p><h2 id="사양"><a href="#사양" class="headerlink" title="사양"></a>사양</h2><p>Java : javac 1.8.0_201-1-ojdkbuild<br>openjdk 1.8 버전에서 동작하는 코드이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;git을 사용하다보면, 폴더만 생성되었거나 폴더 하위의 파일이 없는 경우 stage에 올릴 수 없다.(commit, push 
      
    
    </summary>
    
    
    
      <category term="git" scheme="https://poikilo.github.io/tags/git/"/>
    
      <category term="gitlab" scheme="https://poikilo.github.io/tags/gitlab/"/>
    
      <category term="gitkeep" scheme="https://poikilo.github.io/tags/gitkeep/"/>
    
  </entry>
  
  <entry>
    <title>yaml 기본 문법 정리</title>
    <link href="https://poikilo.github.io/2020/03/03/yaml/"/>
    <id>https://poikilo.github.io/2020/03/03/yaml/</id>
    <published>2020-03-03T02:59:25.000Z</published>
    <updated>2020-03-05T12:02:09.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="기본-구조"><a href="#기본-구조" class="headerlink" title="기본 구조"></a>기본 구조</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parent:</span><br><span class="line">  child-1: first_child</span><br><span class="line">  child-2:</span><br><span class="line">    grandchild-1: first grand child</span><br><span class="line">    grandchild-2: second grand child</span><br></pre></td></tr></table></figure><p>같은 부모를 갖는 자식 노드들은 들여쓰기가 정확히 일치해야 한다.<br>다르면 Error !😂 (<strong>Tab 보다는 space를 활용하자.. vscode의 설정에도 space로 치환하는 것이 있다.</strong>)</p><h2 id="노드"><a href="#노드" class="headerlink" title="노드"></a>노드</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Type 1</span><br><span class="line">key: value</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Type 2</span><br><span class="line">key:</span><br><span class="line">  - child : 1</span><br><span class="line">    name: tom</span><br><span class="line">  - child : 2</span><br><span class="line">    name: john</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Type 3</span><br><span class="line">key:</span><br><span class="line">  child-1: tom</span><br><span class="line">  child-2: john</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">TYPE</th><th>Description</th></tr></thead><tbody><tr><td align="center">Type 1</td><td>기본적인 스칼라 형태의 Key Value 선언</td></tr><tr><td align="center">Type 2</td><td>시퀀스로 이루어진 자식노드들, Array 형태</td></tr><tr><td align="center">Type 3</td><td>매핑으로 이루어진 자식노드들(순서를 보장하지 않는다, Key 문자열로 정렬됨)</td></tr></tbody></table><h2 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h2><p>주석은 # 문자로 시작하는 라인으로만 달 수 있다.<br>스칼라 값 옆에 inline 주석은 불가능하다.<br>작성할 시, 문자열로 취급된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># this is valid comment</span><br><span class="line"></span><br><span class="line">key: value #this is invalid comment.</span><br></pre></td></tr></table></figure><h2 id="anchors-alias"><a href="#anchors-alias" class="headerlink" title="anchors/ alias"></a>anchors/ alias</h2><p>반복되는 값들은 anchor와 alias를 통해 줄일 수 있다.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">anchors:</span><br><span class="line">  # anchor 선언</span><br><span class="line">  first-anchor: &amp;first</span><br><span class="line">    name: tom</span><br><span class="line">    birth: 1999.10.18</span><br><span class="line">  second-anchor: &amp;second</span><br><span class="line">    name: john</span><br><span class="line">    birth: 1995.01.20</span><br><span class="line"></span><br><span class="line">first-child: *first</span><br><span class="line">second-child: *second</span><br></pre></td></tr></table></figure><p>위 코드 처럼 작성하면, first-child key를 통해 first-anchor의 자식노드에 접근 할 수 있다.<br>first-child.name<br>first-child.birth<br>😒😒😒</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;기본-구조&quot;&gt;&lt;a href=&quot;#기본-구조&quot; class=&quot;headerlink&quot; title=&quot;기본 구조&quot;&gt;&lt;/a&gt;기본 구조&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
    
    
      <category term="yaml" scheme="https://poikilo.github.io/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>node-kubernetes-client</title>
    <link href="https://poikilo.github.io/2020/03/03/node-kubernetes-client/"/>
    <id>https://poikilo.github.io/2020/03/03/node-kubernetes-client/</id>
    <published>2020-03-03T02:32:37.000Z</published>
    <updated>2020-03-05T12:02:09.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kubernetes-client-소개"><a href="#kubernetes-client-소개" class="headerlink" title="kubernetes-client 소개"></a>kubernetes-client 소개</h2><p><a href="https://www.npmjs.com/package/kubernetes-client" target="_blank" rel="noopener">npm - kuebernetes-client</a><br>gitlab pipeline의 상태 체크만으로는 kubernetes 클러스터에 온전히 배포가 완료되었는지 체크할 수 없었다.<br>kubernetes-client는 Node.js에서 kubernetes api를 사용할 수 있도록 도와주는 패키지이다.<br>2020-03-03 기준, kubernetes API 1.13 ~ 1.7 버전까지 지원하고 있다.  </p><h2 id="간단-사용법"><a href="#간단-사용법" class="headerlink" title="간단 사용법"></a>간단 사용법</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const &#123; KubeConfig &#125; &#x3D; require(&#39;kubernetes-client&#39;);</span><br><span class="line">const kubeconfig &#x3D; new KubeConfig();</span><br><span class="line">kubeconfig.loadFormFile(&#39;kubeconfig 파일&#39;);</span><br><span class="line">const Request &#x3D; require(&#39;kubernetes-client&#x2F;backends&#x2F;request&#39;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">const backend &#x3D; new Request(&#123; kubeconfig &#125;);</span><br><span class="line">const client &#x3D; new Client(&#123;backend, version: &#39;1.13&#39;&#125;); &#x2F;&#x2F; k8s 클러스터의 api version</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">kubeconfig.setCurrentContext(&#39;context-name&#39;); &#x2F;&#x2F; 이 기능으로 모든 클러스터에 대한 질의를 할 수 있다.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; name space 조회</span><br><span class="line">const namesapces &#x3D; await client.api.v1.namespaces.get()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; deployment 조회</span><br><span class="line">const deployment &#x3D; await client.apis.apps.v1.namespaces(&#39;&lt;&lt; NameSpace &gt;&gt;&#39;).deployments(&#39;&lt;&lt; deployment.meta.name &gt;&gt;&#39;).get()</span><br></pre></td></tr></table></figure><h2 id="최초의-생각"><a href="#최초의-생각" class="headerlink" title="최초의 생각."></a>최초의 생각.</h2><p>kubernetes 클러스터를 여럿 운용하고 있었다.<br>Database에 배포 정보를 저장하고, 클러스터 id key를 기록한다.<br>1분 크론으로 등록하여, 해당 클러스터 정보에 매핑되는 context-name을 불러온다.<br>해당 컨텍스트로 정상 배포되었는지 체크한다.</p><blockquote><p>deployment의 status가 complate 혹은 success 면 배포 성공이 아닐까?</p></blockquote><h2 id="소스코드-작업-진행"><a href="#소스코드-작업-진행" class="headerlink" title="소스코드 작업 진행"></a>소스코드 작업 진행</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">const &#123; KubeConfig, Client &#125; &#x3D; require(&#39;kubernetes-client&#39;);</span><br><span class="line">const kubeconfig &#x3D; new KubeConfig();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 내 PC의 kubeconfig 파일을 선택한다.</span><br><span class="line">kubeconfig.loadFromFile(&#39;D:\\kubectl\\kube.conf&#39;);</span><br><span class="line"> </span><br><span class="line">const Request &#x3D; require(&#39;kubernetes-client&#x2F;backends&#x2F;request&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Initialize to default context</span><br><span class="line">kubeconfig.setCurrentContext(&#39;default&#39;);</span><br><span class="line"> </span><br><span class="line">let backend &#x3D; new Request(&#123; kubeconfig &#125;);</span><br><span class="line">let client &#x3D; new Client(&#123; backend, version: &#39;1.13&#39; &#125;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; context를 변경하려면, 아래 setCurrentContext 함수를 통해 변경한다. :: backend와 client를 재생성해야 처리가능하다.</span><br><span class="line">const setCurrentContext &#x3D; function(context)&#123;</span><br><span class="line">  &#x2F;&#x2F; change to context</span><br><span class="line">  kubeconfig.setCurrentContext(context);</span><br><span class="line"> </span><br><span class="line">  backend &#x3D; new Request(&#123; kubeconfig &#125;);</span><br><span class="line">  client &#x3D; new Client(&#123; backend, version: &#39;1.13&#39; &#125;);</span><br><span class="line">   </span><br><span class="line">  return new Promise(function(resolve, reject)&#123;</span><br><span class="line">    resolve(true);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; namespaces 가져오기.</span><br><span class="line">const namespaces &#x3D; async function()&#123;</span><br><span class="line">  var sNameSpaces &#x3D; await client.api.v1.namespace.get();</span><br><span class="line">  return new Promise(function(resolve, reject)&#123;</span><br><span class="line">    resolve(sNameSpaces);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; deployments 가져오기.</span><br><span class="line">const deployments &#x3D; async function(namespace)&#123;</span><br><span class="line">  var sDeployments &#x3D; await client.apis.apps.v1.namespaces(namespace).deployments().get();</span><br><span class="line"> </span><br><span class="line">  return new Promise(function(resolve, reject)&#123;</span><br><span class="line">    resolve(sDeployments);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exports.namespaces &#x3D; namespaces;</span><br><span class="line">exports.deployments &#x3D; deployments;</span><br><span class="line">exports.setCurrentContext &#x3D; setCurrentContext;</span><br></pre></td></tr></table></figure><h3 id="namespace-items-array-elements"><a href="#namespace-items-array-elements" class="headerlink" title="namespace.items array elements"></a>namespace.items array elements</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; metadata:</span><br><span class="line">   &#123; name: &#39;default&#39;,</span><br><span class="line">     selfLink: &#39;&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#39;,</span><br><span class="line">     uid: &#39;&#123;UID&#125;&#39;,</span><br><span class="line">     resourceVersion: &#39;&#123;resource version -:number&#125;&#39;,</span><br><span class="line">     creationTimestamp: &#39;2019-11-15T01:35:51Z&#39; &#125;,</span><br><span class="line">  spec: &#123; finalizers: [ &#39;kubernetes&#39; ] &#125;,</span><br><span class="line">  status: &#123; phase: &#39;Active&#39; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deployment-items-array-elements"><a href="#deployment-items-array-elements" class="headerlink" title="deployment.items array elements"></a>deployment.items array elements</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123; metadata:</span><br><span class="line">   &#123; name: &#39;deployment name&#39;,</span><br><span class="line">     namespace: &#39;namespace name&#39;,</span><br><span class="line">     selfLink:</span><br><span class="line">      &#39;&#x2F;apis&#x2F;apps&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;deployments&#x2F;deployment_name&#39;,</span><br><span class="line">     uid: &#39;&#123;UID&#125;&#39;,</span><br><span class="line">     resourceVersion: &#39;&#123;resource_version : number&#125;&#39;,</span><br><span class="line">     generation: 81,</span><br><span class="line">     creationTimestamp: &#39;2019-11-21T02:49:31Z&#39;,</span><br><span class="line">     labels:</span><br><span class="line">      &#123; app: &#39;&#123;app_name&#125;&#39;,</span><br><span class="line">        chart: &#39;chart_name-1.0.0&#39;,</span><br><span class="line">        component: &#39;app_name&#39;,</span><br><span class="line">        heritage: &#39;Tiller&#39;,</span><br><span class="line">        release: &#39;release_name&#39; &#125;,</span><br><span class="line">     annotations: &#123; &#39;deployment.kubernetes.io&#x2F;revision&#39;: &#39;32&#39; &#125; &#125;,</span><br><span class="line">  spec:</span><br><span class="line">   &#123; replicas: 5,</span><br><span class="line">     selector: &#123; matchLabels: [Object] &#125;,</span><br><span class="line">     template: &#123; metadata: [Object], spec: [Object] &#125;,</span><br><span class="line">     strategy: &#123; type: &#39;RollingUpdate&#39;, rollingUpdate: [Object] &#125;,</span><br><span class="line">     revisionHistoryLimit: 5,</span><br><span class="line">     progressDeadlineSeconds: 2147483647 &#125;,</span><br><span class="line">  status:</span><br><span class="line">   &#123; observedGeneration: 81,</span><br><span class="line">     replicas: 5,</span><br><span class="line">     updatedReplicas: 5,</span><br><span class="line">     readyReplicas: 5,</span><br><span class="line">     availableReplicas: 5,</span><br><span class="line">     conditions: [ [Object] ] &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="deployment-items-n-status-conditions"><a href="#deployment-items-n-status-conditions" class="headerlink" title="deployment.items[n].status.conditions"></a>deployment.items[n].status.conditions</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; type: &#39;Available&#39;,</span><br><span class="line">    status: &#39;True&#39;,</span><br><span class="line">    lastUpdateTime: &#39;2019-12-06T03:10:29Z&#39;,</span><br><span class="line">    lastTransitionTime: &#39;2019-12-06T03:10:29Z&#39;,</span><br><span class="line">    reason: &#39;MinimumReplicasAvailable&#39;,</span><br><span class="line">    message: &#39;Deployment has minimum availability.&#39; &#125; ]</span><br></pre></td></tr></table></figure><h2 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h2><p>Deployment의 Status는 MinimumReplicasAvailable에서 확인 할 수 있 듯, 최소 replica 수를 만족하는지만 체크한다. :: 배포 정책이 rolling update이기 때문에..</p><h2 id="차안"><a href="#차안" class="headerlink" title="차안"></a>차안</h2><p>Deployment에 연결된 Pod들의 상태를 모두 체크한다.<br>Rolling update 배포 방식이어도, 모든 파드가 Running일때만 성공으로 확인하면 배포 상태를 잡을 수 있다.</p><h2 id="소스-작업-2차"><a href="#소스-작업-2차" class="headerlink" title="소스 작업 :: 2차"></a>소스 작업 :: 2차</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">const &#123; KubeConfig, Client &#125; &#x3D; require(&#39;kubernetes-client&#39;);</span><br><span class="line">const kubeconfig &#x3D; new KubeConfig();</span><br><span class="line">kubeconfig.loadFromFile(&#39;D:\\kubectl\\kube.conf&#39;);</span><br><span class="line">const Request &#x3D; require(&#39;kubernetes-client&#x2F;backends&#x2F;request&#39;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Initialize to default</span><br><span class="line">kubeconfig.setCurrentContext(&#39;default&#39;);</span><br><span class="line"> </span><br><span class="line">let backend &#x3D; new Request(&#123; kubeconfig &#125;);</span><br><span class="line">let client &#x3D; new Client(&#123; backend, version: &#39;1.13&#39; &#125;);</span><br><span class="line"> </span><br><span class="line">const setCurrentContext &#x3D; function(context)&#123;</span><br><span class="line">  &#x2F;&#x2F; change to context</span><br><span class="line">  kubeconfig.setCurrentContext(context);</span><br><span class="line"> </span><br><span class="line">  backend &#x3D; new Request(&#123; kubeconfig &#125;);</span><br><span class="line">  client &#x3D; new Client(&#123; backend, version: &#39;1.13&#39; &#125;);</span><br><span class="line">   </span><br><span class="line">  return new Promise(function(resolve, reject)&#123;</span><br><span class="line">    resolve(true);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const namespaces &#x3D; async function()&#123;</span><br><span class="line">  var sNameSpaces &#x3D; await client.api.v1.namespace.get();</span><br><span class="line">  return new Promise(function(resolve, reject)&#123;</span><br><span class="line">    resolve(sNameSpaces);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const deployments &#x3D; async function(namespace)&#123;</span><br><span class="line">  var sDeployments &#x3D; await client.apis.apps.v1.namespaces(namespace).deployments().get();</span><br><span class="line"> </span><br><span class="line">  return new Promise(function(resolve, reject)&#123;</span><br><span class="line">    resolve(sDeployments);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const getDeploymentStatus &#x3D; async function(namespace, deployment)&#123;</span><br><span class="line">  var sDeploymentStatus &#x3D; await client.apis.apps.v1beta1.namespaces(namespace).deployments(deployment).get();</span><br><span class="line"> </span><br><span class="line">  return new Promise(function(resolve, reject)&#123;</span><br><span class="line">    resolve(sDeploymentStatus);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Pod Status를 확인하기 위함. api를 활용하여 namespace의 pods.get(QueryString.labelSelector) 체크.</span><br><span class="line">const getPodsStatus &#x3D; async function(namespace, labelSelector)&#123;</span><br><span class="line">  var qs &#x3D; &#123;</span><br><span class="line">    labelSelector: labelSelector</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  var sPodStatus &#x3D; await client.api.v1.namespaces(namespace).pods.get(&#123;qs: qs&#125;);</span><br><span class="line"> </span><br><span class="line">  return new Promise(function(resolve, reject)&#123;</span><br><span class="line">    resolve(sPodStatus);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exports.namespaces &#x3D; namespaces;</span><br><span class="line">exports.deployments &#x3D; deployments;</span><br><span class="line">exports.setCurrentContext &#x3D; setCurrentContext;</span><br><span class="line">exports.getDeploymentStatus &#x3D; getDeploymentStatus;</span><br><span class="line">exports.getPodsStatus &#x3D; getPodsStatus;</span><br></pre></td></tr></table></figure><p>Pod의 metadata - label을 통해 Deployment에 연결된 Pod들을 조회할 수 있었고<br>해당 Pod들의 상태가 모두 Running이어야 배포 완료로 체크하여 처리했다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;kubernetes-client-소개&quot;&gt;&lt;a href=&quot;#kubernetes-client-소개&quot; class=&quot;headerlink&quot; title=&quot;kubernetes-client 소개&quot;&gt;&lt;/a&gt;kubernetes-client 소개&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="kubernetes" scheme="https://poikilo.github.io/tags/kubernetes/"/>
    
      <category term="api" scheme="https://poikilo.github.io/tags/api/"/>
    
      <category term="node" scheme="https://poikilo.github.io/tags/node/"/>
    
      <category term="npm" scheme="https://poikilo.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>Confluence TIP</title>
    <link href="https://poikilo.github.io/2020/03/02/confluence-tip/"/>
    <id>https://poikilo.github.io/2020/03/02/confluence-tip/</id>
    <published>2020-03-02T08:43:10.000Z</published>
    <updated>2020-03-02T21:46:28.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>Confluence 활용 팁을 정리한다.  </p><h2 id="Short-cuts-단축키"><a href="#Short-cuts-단축키" class="headerlink" title="Short cuts. (단축키)"></a>Short cuts. (단축키)</h2><p>자주 사용하는 단축키를 정리한다.  </p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td>e</td><td>페이지 편집</td></tr><tr><td>“—-“</td><td>가로 줄 넣기</td></tr><tr><td>ctrl+shift+i</td><td>표 생성</td></tr><tr><td>alt+방향키(위/아래)</td><td>표에서 행 추가</td></tr><tr><td>h{number}.</td><td>서식 지정(제목/ 본문)</td></tr><tr><td>ctrl+{number}</td><td>서식 지정(제목/ 본문)</td></tr><tr><td>[]</td><td>Todo 지정</td></tr><tr><td>//</td><td>Date picker.</td></tr><tr><td>@</td><td>mention</td></tr><tr><td>ctrl+s</td><td>저장 - 제목 편집중에는 작동하지 않는다.</td></tr><tr><td>–&gt;</td><td>화살표 방향대로. dash를 두개 넣으면 자동 변환한다.</td></tr><tr><td>*</td><td>목록화 하여 표시할 내용이 있다면 사용. Tab 키를 통해 Level을 맞출 수 있다.</td></tr><tr><td>ctrl+z</td><td>되돌리기. 매크로나, 자동변경사항을 돌릴 수 있다.</td></tr><tr><td>[link-url]</td><td>링크</td></tr></tbody></table><h2 id="개인공간-Style-지정"><a href="#개인공간-Style-지정" class="headerlink" title="개인공간 Style 지정."></a>개인공간 Style 지정.</h2><p>side bar의 하단에 있는 톱니바퀴 버튼(공간 도구) 클릭.<br>모양새 선택<br>색상 구성 선택<br><a href="https://www.webdesignrankings.com/resources/lolcolors/" target="_blank" rel="noopener">Hexa code 링크</a> 참고하여 기존 Confluence style에서 벗어나자..<br>폰트의 변경은 아래를 참고한다  </p><ul><li>D2 coding 스타일 적용.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@import url(&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Joungkyun&#x2F;font-d2coding@1.31.0&#x2F;d2coding.css&#39;);</span><br><span class="line">@import url(&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Joungkyun&#x2F;font-d2coding@1.31.0&#x2F;d2coding-ligature.css&#39;);</span><br><span class="line">body &#123; font-family: &#39;D2 coding Ligature&#39;;&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;Confluence 활용 팁을 정리한다.  &lt;/p&gt;
&lt;h2 id=&quot;Short-cuts-단축키&quot;&gt;&lt;a href=&quot;#Short-c
      
    
    </summary>
    
    
    
      <category term="atlassian" scheme="https://poikilo.github.io/tags/atlassian/"/>
    
      <category term="wiki" scheme="https://poikilo.github.io/tags/wiki/"/>
    
      <category term="confluence" scheme="https://poikilo.github.io/tags/confluence/"/>
    
  </entry>
  
  <entry>
    <title>JIRA Tip</title>
    <link href="https://poikilo.github.io/2020/03/02/jira-tip/"/>
    <id>https://poikilo.github.io/2020/03/02/jira-tip/</id>
    <published>2020-03-02T08:23:30.000Z</published>
    <updated>2020-03-02T21:46:28.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-용어-정리"><a href="#01-용어-정리" class="headerlink" title="01. 용어 정리"></a>01. 용어 정리</h2><ul><li>Projects<br>프로젝트는 같은 목적 또는 공동의 맥락을 가진 이슈들의 집합이다.</li><li>Issue<br>이슈는 사이즈 무관의 단위 작업을 뜻하며, 시작과 종료까지 Tracking이 필요한 작업을 의미한다.<br>다른 말로는 Requests, Tickets, Tasks로 불린다.  </li><li>Workflow<br>이슈의 단계는 여러가지가 될 수 있다. 워크 플로우는 이슈 처리에 대한 일련의 작업상태를 뜻한다.<br>예시로, Open -&gt; In Progress -&gt; Under Review -&gt; Final Approval -&gt; Done.<br>최종 완료상태인 Done/Resolved/Closed를 제외한 각 단계는 서로 ping-pong이 가능하다.  </li><li>Agile<br>Agile은 소프트웨어 개발 방법론 중 하나로, 고객의 요청(요구사항)에 따라 빠른 프로토타이핑을 진행하며 Feedback을 통해 소프트웨어를 개선해 나가는 작업을 수행한다.<br>지속적인 개발을 통해 서비스를 개선해 나가는 작업에 적합하다. (B2C 서비스들)<br>빠른 프로토타이핑을 통해 고객의 의견수렴에 적응이 빠르다.  </li></ul><h2 id="Start-with-6-Steps"><a href="#Start-with-6-Steps" class="headerlink" title="Start with 6 Steps."></a>Start with 6 Steps.</h2><p><strong>Step 1. Create Project</strong><br><strong>Step 2. Pick a Template</strong><br>  Template(Scrum, Kanban, Bug Tracking) 제공.<br>  팀이나 회사에서 Template을 잘 만들어서 관리하면 산출물 작성에 큰 도움이 된다.<br><strong>Step 3. Board Setup</strong><br>  할당된 Issue, 진행중 Issue 등 프로젝트에서 진행하고 있는 Issue에 대한 Dashboard를 제공한다.<br>  이를 개인의 목적에 맞게 적용하여 개인 Dashboard에서 활용할 수 있다.<br><strong>Step 4. Issue 생성</strong><br>  Back log에 Issue가 생성된다.<br><strong>Step 5. 팀원 초대</strong><br>  프로젝트에 참여하는 팀원을 초대한다.<br><strong>Step 6. Workflow Setup</strong><br>  Board에서 할당된 Issue의 진행사항등을 Drag &amp; Drop을 통해 상태를 변경한다.  </p><h2 id="JQL"><a href="#JQL" class="headerlink" title="JQL"></a>JQL</h2><p>Jira의 데이터를 조회할때 사용하는 Query Language이다.<br>잘 사용하면 프로젝트, 이슈의 종류, 일정관리 등에 도움이 된다.<br>DB Query(SQL)을 알고 있는 사용자라면, 좀 더 쉽게 배울 수 있다.</p><ul><li>사용 예<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 현재 로그인 한 사용자에게 할당된 이슈 검색.</span><br><span class="line">assignee &#x3D; currentUser()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 내가 담당자인 이슈 중, 처리되지 않은 이슈 검색</span><br><span class="line">assignee &#x3D; currentUser() and status not in (resolved, closed, done)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 특정 이슈의 하위 이슈(sub-task) 검색</span><br><span class="line">Project &#x3D; &#123;project_name&#125; and parent &#x3D; &#123;issue_key&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 지난주에 상태를 변경한 이슈</span><br><span class="line">status changed during (startOfWeek(-1), endOfWeek(-1)) order by updatedDate</span><br></pre></td></tr></table></figure></li></ul><h2 id="개인에게-할당된-월별-이슈-조회"><a href="#개인에게-할당된-월별-이슈-조회" class="headerlink" title="개인에게 할당된 월별 이슈 조회"></a>개인에게 할당된 월별 이슈 조회</h2><p>개인의 filter를 사용하면 훨씬 더 간단해 지겠지만, JIRA를 건드리지 않고 조회하는 JQL을 설명한다.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2020-03에 생성된 이슈이면서, 아직 완료되지 않은 건.</span><br><span class="line">assignee &#x3D; currentUser() and status not in (closed, resolved, done) and createdDate &lt;&#x3D; &#39;2020-03-01&#39; and createdDate &lt; &#39;2020-04-01&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2020-03 이전에 생성된 이슈이면서, 아직 완료되지 않은 건.</span><br><span class="line">assignee &#x3D; currentUser() and status not in (closed, resolved, done) and  createdDate &lt; &#39;2020-03-01&#39;</span><br></pre></td></tr></table></figure><p>Confluence의 Jira Macro를 활용하여 사용한다면, 매달의 현황을 체크할 수 있다.  </p><h2 id="Issue의-Tag-활용"><a href="#Issue의-Tag-활용" class="headerlink" title="Issue의 Tag 활용"></a>Issue의 Tag 활용</h2><p>개발 팀명, 프로젝트 기간, 이슈 타입, 개인화 태그를 추가하면 검색에 좀 더 용이할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;01-용어-정리&quot;&gt;&lt;a href=&quot;#01-용어-정리&quot; class=&quot;headerlink&quot; title=&quot;01. 용어 정리&quot;&gt;&lt;/a&gt;01. 용어 정리&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Projects&lt;br&gt;프로젝트는 같은 목적 또는 공동의 맥락을 가진 
      
    
    </summary>
    
    
    
      <category term="atlassian" scheme="https://poikilo.github.io/tags/atlassian/"/>
    
      <category term="jira" scheme="https://poikilo.github.io/tags/jira/"/>
    
      <category term="issue" scheme="https://poikilo.github.io/tags/issue/"/>
    
      <category term="tracker" scheme="https://poikilo.github.io/tags/tracker/"/>
    
  </entry>
  
  <entry>
    <title>버전관리 도구</title>
    <link href="https://poikilo.github.io/2020/03/02/version-control/"/>
    <id>https://poikilo.github.io/2020/03/02/version-control/</id>
    <published>2020-03-02T06:03:40.000Z</published>
    <updated>2020-03-02T21:46:28.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Configuration-Management-CM-형상관리"><a href="#Configuration-Management-CM-형상관리" class="headerlink" title="Configuration Management(CM; 형상관리)"></a>Configuration Management(CM; 형상관리)</h2><ul><li><p><strong>Definition</strong><br>CM(형상관리)은 제품의 성능, 기능성, 요구사항 중 물리적 조건, 디자인 제품의 생명주기 전반에 걸친 운영에 필요한 정보 등을 ㅗ구성된 구축과 유지보수에 대한 시스템 엔지니어링 프로세스 이다.<br>쉽게 말해서, 제품을 만들고 유지관리하는데 수반되는 프로세스라 생각하면 된다.  </p></li><li><p><strong>SCM(Software Configuration Management; 소프트웨어 형상관리)</strong><br>소프트웨어를 개발, 유지보수 하는데 있어 소프트웨어의 변경사항 뿐만 아니라 관련 산출물들에 대한 변경사항을 추적/ 통제하기 위한 프로세스이다.  </p></li><li><p><strong>SDLC(Software Development LifeCycle; 소프트웨어 개발 생명주기)</strong><br>소프트웨어의 개발 생명주기. 보통 생각하는 요구사항 분석 - 설계 - 개발 - 테스트 - 이행(배포) - 모니터링 정도로 생각하면 된다.<br>SCM은 SDLC의 각 단계별 산출물과, 소스코드의 변경을 추적 관리한다.</p></li><li><p><strong>필요성</strong><br>혼자 개발하는 경우가 거의 없기 때문에.<br>개발자(SI)와 운영자(SM)는 다른 경우가 대부분이기 때문에.<br>시스템의 규모가 클 수록 변경사항에 대한 체계적 관리가 필요해졌기 때문에.</p></li><li><p><strong>개인 의견</strong><br>흔히 형상관리 하면 소스코드의 버전관리를 생각하는 경우가 대부분이다.<br>정의에 담겨있듯, 단순히 소스코드의 버전관리가 아니라 SDLC에서 도출되는 모든 산출물이 그 대상이라고 할 수 있다.<br>기업마다 관리하는 프로세스의 정도(Level)이 다르기 때문에, 그 범위가 다르다.<br>간단한 예로, 자동차에 들어가는 소프트웨어 개발 품질관리 정책과 웹 서비스에 필요한 소프트웨어 개발 프로세스 정책은 확실히 다르다.<br>critical한 시스템일 수록 소프트웨어에 대한 품질관리가 철저히 이루어져야 하며 국제 표준또한 많이 나와있다. A-SPICE, ISO-26262 등  </p></li></ul><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul><li><strong>Git</strong><br>파일의 변경사항을 추적하고, 여러명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전관리 시스템이다.<br>대개 소스코드 관리에 사용되지만, 어떤 집합의 파일의 변경사항을 지속적으로 추적하기 위해 사용될 수 있다.(e.g., 산출물 - 기획문서 등 version 관리 가능)<br>Git을 기반으로 사용하는 다양한 툴이 개발되어 있다.<br>Git의 장점은 브랜치 관리 - <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow" target="_blank" rel="noopener">git flow 참고 - Atlassian bitbucket tutorial</a><br><a href="https://github.com" target="_blank" rel="noopener">github</a><br><a href="https://gitlab.com" target="_blank" rel="noopener">gitlab</a><br><a href="https://bitbucket.com" target="_blank" rel="noopener">bitbucket</a>  </li><li><strong>Subversion</strong><br>Apache 프로젝트, Server-client 모델을 따른 시스템이다.<br>서버에 저장소를 두고, 클라이언트에서 push pull 작업을 진행한다.<br>Eclipse-java 프로젝트를 진행하며 회사에서 사용 해 보았다. 서버에 설치가 간단하며, CLI, GUI 환경 모두 지원한다.<br>windows 계열에는 visual svn(server), tortoiseSVN(client)<br>Linux 계열에는 subversion 설치 확인.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Configuration-Management-CM-형상관리&quot;&gt;&lt;a href=&quot;#Configuration-Management-CM-형상관리&quot; class=&quot;headerlink&quot; title=&quot;Configuration Management(CM;
      
    
    </summary>
    
    
    
      <category term="VCS" scheme="https://poikilo.github.io/tags/VCS/"/>
    
      <category term="software version control" scheme="https://poikilo.github.io/tags/software-version-control/"/>
    
  </entry>
  
  <entry>
    <title>SOLID, KISS, YANGI</title>
    <link href="https://poikilo.github.io/2020/03/02/design-concept/"/>
    <id>https://poikilo.github.io/2020/03/02/design-concept/</id>
    <published>2020-03-02T05:53:59.000Z</published>
    <updated>2020-03-02T21:46:28.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SOLID-객채지향-개발-5대-원리"><a href="#SOLID-객채지향-개발-5대-원리" class="headerlink" title="SOLID : 객채지향 개발 5대 원리."></a>SOLID : 객채지향 개발 5대 원리.</h2><ul><li>SRP(Single Responsibility Principle : 단일 책임의 원칙)<br>작성된 클래스는 하나의 기능만을 가지며, 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어야 한다는 원칙.<br>어떤 변화에 의해 <strong>클래스를 변경해야 하는 이유는 오직 하나여야</strong> 함을 의미한다.</li><li>OCP(Open Close Principle : 개방 폐쇄의 원칙)<br>소프트웨어 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원칙이다.<br>요구사항의 변경이나 추가사항이 발생하더라도, <strong>기존 구성요소는 수정이 일어나지 말아</strong>야 하며, 기존 구성요소를 <strong>쉽게 확장하여 재사용</strong> 할 수 있어야 한다는 것.</li><li>LSP(The Liskov Substitution Principle : 리스코브 치환의 원칙)<br>서브 타입은 언제나 기반타입으로 교체할 수 있어야 한다.(상속과 구현에 대한 내용)<br>서브 클래스가 확장에 대한 인터페이스를 준수해야 한다는 것을 의미한다.</li><li>ISP(Interface Segration Principle : 인터페이스 분리의 원칙)<br>한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리이다. - 최소한의 인터페이스만을 사용한다.</li><li>DIP(Dependency Inversion Principle : 의존성 역전의 원칙)<br>의존 관계의 역전이란, 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전이다.<br>실제 사용관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고 받음으로써, 관계를 최대한 느슨하게 만드는 원칙이다.</li></ul><h2 id="KISS-Keep-It-Simple-Stupid"><a href="#KISS-Keep-It-Simple-Stupid" class="headerlink" title="KISS : Keep It Simple Stupid."></a>KISS : Keep It Simple Stupid.</h2><p>소프트웨어를 설계하는 작업이나, 코딩을 하는 행위에서 되도록이면 간단하고 단순하게 만드는 것이 좋다는 원리이다.(Simple is Best)<br>소스코드나 설계 내용이 불필요하게 장황하거나 복잡해지는 것을 경계하라는 원칙.</p><h2 id="YANGI-You-Ain’t-Gonna-Need-It"><a href="#YANGI-You-Ain’t-Gonna-Need-It" class="headerlink" title="YANGI : You Ain’t Gonna Need It"></a>YANGI : You Ain’t Gonna Need It</h2><p>필요한 작업만을 하라는 의미이다.<br>프로그램을 작성하다보면, 현재는 사용하지 않지만, 확장성을 고려해 미리 작업하는 경우가 많다. :: 이런 행위를 하지말라는 원칙.<br>현재는 사용하지 않는 코드들을 작성하다 보면, 설계와 맞지 않거나 붎릴요하게 장황해지는 코드를 확인할 수 있다.<br>설계나 환경의 변경이 발생되었을 때, 찾기 어렵다. 수정사항도 많아진다…<br>실제 사용 여부를 판단할 수 없어, 전부를 고쳐야하는 상황이 벌어진다..<br>이런 경우를 피하기 위해 사용하지 않는 코드는 작성하지 말자는 원칙!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SOLID-객채지향-개발-5대-원리&quot;&gt;&lt;a href=&quot;#SOLID-객채지향-개발-5대-원리&quot; class=&quot;headerlink&quot; title=&quot;SOLID : 객채지향 개발 5대 원리.&quot;&gt;&lt;/a&gt;SOLID : 객채지향 개발 5대 원리.&lt;/h2
      
    
    </summary>
    
    
    
      <category term="design" scheme="https://poikilo.github.io/tags/design/"/>
    
      <category term="concept" scheme="https://poikilo.github.io/tags/concept/"/>
    
      <category term="software" scheme="https://poikilo.github.io/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>CI(Continuous Integration)</title>
    <link href="https://poikilo.github.io/2020/03/02/ci-server/"/>
    <id>https://poikilo.github.io/2020/03/02/ci-server/</id>
    <published>2020-03-02T05:16:57.000Z</published>
    <updated>2020-03-02T21:46:28.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CI-Continuous-Integration-지속적-통합"><a href="#CI-Continuous-Integration-지속적-통합" class="headerlink" title="CI(Continuous Integration) : 지속적 통합"></a>CI(Continuous Integration) : 지속적 통합</h2><ul><li>소프트웨어 공학에서 CI(;지속적 통합)이란, 모든 개발자의 작업 산출물을 하루에 여러번 통합(Merge)하는 작업을 의미한다.</li><li>XP(Extream Programming) 방법론에서는 CI의 컨셉을 적용하여 하루에 수십번 통합하는 작업을 진행한다.</li></ul><h2 id="Common-Practice-일반적-관행"><a href="#Common-Practice-일반적-관행" class="headerlink" title="Common Practice : 일반적 관행"></a>Common Practice : 일반적 관행</h2><ul><li><p>Maintain a code Repository<br>소스 코드 저장소를 유지관리하는 것을 의미한다. : version control.</p></li><li><p>Automated Build<br>자동 compile -&gt; linking -&gt; build 과정을 거쳐 최종 배포될 산출물을 만드는 것을 의미한다. : build automation</p></li><li><p>Make the build self-testing<br>코드가 빌드되면, 모든 테스트는 개발자가 의도한대로 동작하는지 테스트를 수행해야 한다. : Unit Test(기능단위 테스트), Integration Test(통합테스트), Static Analysis(정적분석; 코드 품질관리)</p></li><li><p>Everyone commits to the base line every day<br>정기적인 commit을 하는 것은, 모든 committer가 변경사항의 충돌을 줄일 수 있다. 1주간의 업무점검은 해결하기 어려운 다른 형상과의 충돌위험을 줄일 수 있다.<br>일찍이, 사소한 충돌이 발생하는 것은 팀 멤버들이 자신들이 만드는 것의 변화에 대해 소통하게 한다.<br>적어도 하루에 한번모든 변경사항을 commit 하는 것은 CI의 정의 중 한 부분으로 간주된다.<br>일반적으로, 새벽에 빌드하는 것이 추천된다.</p></li><li><p>Every Commit to Baseline shuld be built<br>시스템은 커밋된 사항들이 통합된 것(시스템 자체)을 검증하기 위해 현재의 버전에 커밋된 사항을 빌드해야 한다.<br>일반적 관행으로 자동 CI를 사용한다.(몇몇은 수동으로 진행할 수 있다.)<br>CI 자동화 시스템은 지속적인 통합서버(CI Server) 또는 데몬을 사용하여 변경 관리 시스템(revision control system) 을 모니터링 하고, 빌드 프로세스를 자동으로 실행한다.</p></li><li><p>Keep the build fast<br>빌드는 빠르게 완료될 필요가 있다. 통합에 문제가 발생하면 빠르게 감지되어야 한다.</p></li><li><p>Test in a clone of the production environment<br>운영 환경과 테스트 환경이 다르기 때문에, 테스트 된 시스템이더라도 운영환경에서 error가 발생할 수 있다.<br>운영환경을 똑같이 복제한 환경을 구축하는 것은 비용이 많이 든다.<br>테스트 환경 대신 pre-production(simulation) 환경을 구축한다.<br>pre-production 환경은 기술스택 구성을 유지하면서 비용을 절감할 수 있다.<br>이러한 테스트 환경에서 서비스 가상화는 의존형에 대한 on-demand access를 얻는데 일반적으로 사용한다.</p></li><li><p>Make it easy to get the latest deliverable<br>시스템 이해 관계자와 테스터가 쉽게 사용할 수 있는 빌드 도구를 만들면, 요구사항을 충족하지 않는 기능을 다시 빌드할 때 필요한 재 작업의 양을 줄일 수 있다.<br>추가적으로 앞선 테스팅은 배포되기까지 남아있는 결함을 줄일 수 있는 기회를 준다.<br>에러를 빠르게 감지하는 것은 그 에러를 해결하는데 필요한 작업의 양을 줄일 수 있다.</p></li><li><p>Everyone can see the result of the latest build<br>모든 사람이 최신의 빌드 결과를 확인할 수 있다.<br>이는 빌드의 중단점을 찾기 쉽게 도와주며, 빌드가 중단되었다면 어떤 변화가 중단을 일으켰는지, 중단의 원인이 되는 변경사항을 개발한 사람은 누구인지 확인할 수 있게 한다.</p></li><li><p>Automate deployment<br>대부분의 CI 시스템은, 빌드가 종료되는 순간 script를 수행할 수 있는 기능을 제공한다.<br>대부분의 경우 운영중인 테스트 서버(모든 사람이 볼 수 있는)에 application을 배포하는 스크립트를 작성한다.<br>이러한 사고방식의 발전으로 지속적인 배포가 등장하게 되고, 지속적인 배포에는 소프트웨어를 운영환경에 직접 배포하고 결함 또는 회귀를 방지하기 위한 추가 자동화가 필요하다.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CI-Continuous-Integration-지속적-통합&quot;&gt;&lt;a href=&quot;#CI-Continuous-Integration-지속적-통합&quot; class=&quot;headerlink&quot; title=&quot;CI(Continuous Integration) :
      
    
    </summary>
    
    
    
      <category term="CI" scheme="https://poikilo.github.io/tags/CI/"/>
    
      <category term="S/E" scheme="https://poikilo.github.io/tags/S-E/"/>
    
      <category term="software engineering" scheme="https://poikilo.github.io/tags/software-engineering/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes#1 용어정리</title>
    <link href="https://poikilo.github.io/2020/02/27/kubernetes-1/"/>
    <id>https://poikilo.github.io/2020/02/27/kubernetes-1/</id>
    <published>2020-02-27T07:21:00.000Z</published>
    <updated>2020-03-02T21:46:28.916Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Kubernetes-용어-정리"><a href="#Kubernetes-용어-정리" class="headerlink" title="Kubernetes 용어 정리"></a>Kubernetes 용어 정리</h4><table><thead><tr><th>Term</th><th>Description</th><th>etc</th></tr></thead><tbody><tr><td>Cluster</td><td>여러 대의 서버(Node)를 묶어, 하나의 자원처럼 사용하는 것.<br><br></td><td></td></tr><tr><td>Node</td><td>클러스터 구성의 기본 단위. 물리서버 1대가 될 수도 있고, Openstack VM Instance 한대가 될 수도 있다.<br><br></td><td></td></tr><tr><td>Master-Node</td><td>Kubernetes의 System Operator 역할, coordinator 역할을 수행하는 Pod들이 올라가 있는 곳.<br>Pod의 Scheduling, Metric 계산(matric-server), Tiller, Dashboard 등이 올라갈 수 있다.<br>kubernetes api 자원관리, 네트워크관리, api 등 kubernetes의 시스템적인 운영을 담당하는 노드이다.<br><br></td><td></td></tr><tr><td>Worker-Node</td><td>사용자가 배포하는 application, service가 동작하는 노드이다.<br><br></td><td></td></tr><tr><td>CRE</td><td>Container Runtime Environment<br>- 컨테이너를 구동하는 환경을 의미한다. <br>- 대표적 예로, Docker와 Container.d가 있다.<br><br></td><td></td></tr><tr><td>Container</td><td>CRE에서 동작하는 단위<br>Virtual Machine과 다르게, Host의 OS, Kernel의 자원을 공유한다.<br>때문에 더 가볍다는 의견.<br><br></td><td></td></tr><tr><td>Pod</td><td>Container를 1개이상 포함하는, Kubernetes의 서비스 최소단위.<br><br></td><td></td></tr><tr><td>Service</td><td>CRE에서 제공하는 내부 네트워크 ip 대역을 추상화 한 개념이다.<br>실제로 사용자는 어떻게 container가 생성되었고, 어떤 내부 ip를 할당받았는지 알수 없기 때문에 kubernetes에서는 Service라는 개념을 도입.<br>Service 명을 통해 Pod에 접속 또는 연결(Connect)하게 된다.<br><strong>Service는 해당 Pod들에 외부/내부에서 접속하기 위한 IP, Port를 설정</strong> 할 수 있다.<br>Service는 <strong>Pod와 연결하기 위해 Label Selector</strong> 라는 개념을 사용한다.<br>Pod의 Metadata에 Label을 기재하도록 하는데, 이를 통해 서비스와 연결한다.<br> (HTML의 Query Selector, JQuery의 Class select 방식을 생각하면 좀 더 이해하기 쉽다.)<br><br></td><td></td></tr><tr><td>Ingress</td><td>ingress는 도메인, path를 통해 어떤 서비스와 연결할지 설정이 가능하다.<br>e.g., domain *.mypage.com 에 대해 backend는 서비스명 homepage-service<br>path는 “/“에 대해 *.mypage.com/ 으로 접속하면 homepage-service와 연결<br>ServicePort는 80 http프로토콜 접속을 허용한다는 것.<br> <strong>외부에서 도메인틀 통한 접속 -&gt; ingress 설정을 확인하여 해당하는 서비스와 연결 -&gt; 해당 서비스에 매핑되어있는 Pod에 연결</strong> <br><br></td><td></td></tr><tr><td>Replica Set</td><td>Single point failure를 제어하기 위한 개념.<br>Pod의 수를 제어한다.<br>Replica Set, Replica Controller는 Pod의 수를 제어한다. 실제 running중인 Pod의 수가 ReplicaSet에 기재된 replica count보다 작다면, Deployment에 기재된 Pod의 template를 참조하여 Pod를 추가로 생성한다.<br><br></td><td></td></tr><tr><td>Stateful Set</td><td>컨테이너가 제거 또는 재시작 되어도, <strong>상태의 영속성</strong> 을 보장해야 하는 워크로드에 사용된다.<br>e.g., Database Nginx 등<br><br></td><td></td></tr><tr><td>Daemon Set</td><td>솔루션의 모니터링, 로깅 등을 다른 App의 구동과는 무관하게 지속적으로 실행되어야 하는 app을 위해 사용한다.<br><br></td><td></td></tr><tr><td>Deployment</td><td>Replica Set과 Pod를 정의할 수 있도록 추상화 한 개념<br>Deployment를 kuberctl apply를 통해 적용하면, Deployment, Replica Set, Pod가 생성된다. <br>Deployment를 삭제하더라도, ReplicatSet이 남아있다면 Pod는 삭제되지 않는다.<br>Deployment, ReplicaSet을 모두 제거해야만 Pod가 삭제된다.<br><br></td><td></td></tr></tbody></table><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;www.draw.io\&quot; modified=\&quot;2020-02-19T03:54:52.703Z\&quot; agent=\&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36\&quot; etag=\&quot;e54n-G_G8oxnpoMZRh6N\&quot; version=\&quot;12.7.1\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;4Cl5Zr4XpdmF6iXK8EqK\&quot; name=\&quot;Page-1\&quot;&gt;7Vpbc5s4GP01fkwGEJLFY+pkd/PQTmb9kPapI8PHZRZbrpBv++srQGDA6m7acvEkIXlAR+KTpXOO0Hxihhbr45+CbeOPPIB05ljBcYbuZ45ju44zy/+t4FQijkXsEolEEuhWZ2CZ/AsatDS6SwLIWg0l56lMtm3Q55sN+LKFMSH4od0s5Gm71y2L4AJY+iy9RJ+TQMYlSp35Gf8LkiiueraJV9asWdVYjySLWcAPDQg9zNBCcC7Lu/VxAWk+e9W8lM/98YPa+ocJ2MiXPHD3+fHLVxY97j/snIh7z8+bjzc3OsqepTs94JlDUhXvw0rdRPlNBYRc9aOGIU96bsi3Ha8qbrKCuTvVwPa2x3NlFWWR7jIJoo4uuuHfkakQJZmS2wu4oQGnRb0j+G4TQK4sW1Uf4kTCcsv8vPagVgKFxXKd6uowSdMFT7konkW+DzgMFZ5Jwf+BRg0iyENB3d8ehITjD+Vu1yZSyw/wNUhxUk30A0jbTi88Ntblw9nFc09jccPBuPIr0ytHVIc+m0vdaH/9hNecAbw2N3ntk1qGr0NabxkZ21ZQXEPbym3bqn5PN2zlYIOtXDyUrfAAtqImW93DNuWnNRScXoHArlGEYRg6vm8SYUBWBJN+RIjbInRNIkQGEdbq7V2EZKy1/W8lwsRnS5CTUYzzPxPFpLj0SJrrT3H1Qz3pUE8N1NsG6slQzM8HYJ6YmH/iwWSvFjvAMDdR7pE5Yj252mtTi007tjGZpe/M9sSs3dmMYzIxtd5rpDZgWVy37YE1x7oy1qp1ffi37BLEPvFhKlcqT9LANbmSOitEenJl51WK3KlfpfYQ2Sgjv4+bSECWTcYvAxoad8nEp7AKB+HXMdh3ZH7fMyBvCnmdGRDc9dX0KRAbvRvrLSGv01jIuj5juQMYy3g+9nCUIDYs/0V3vv+bexM1smSbFYTFbJuDfsp3wU/zvrIAATHxbgG1KO2Hd9tu835j2Khg01GNPdxOxZRU7k7yJrjLD5iL2WVZlpQbOibkJdyY4jIOBBfHzp3pUn3xnfDhBftl1WcE8n9lfElAc4JNR2EaE5AymezbP9g057qHJ54UVjCfxM27SdhynPqhM3EXcWg7DvE6ccppuIhTCKAe9G9owpTj7UcTcEzkZ3Vv3WJd+lKUaJE1zcv3+RxYVeHUKDyBSNTQQGjspfqaSg02cW9pi0iEvVuP/pomDNGskWVhSgBf3VJBp6Z87jUu3GLMRYp/79f5/4/QiFq3lj2uHkxp43H1MBXP9adOVcKw+ynFS1ntvjIwHdnTrz8/PMk5wIgZZVU8f1pX6uL8hSJ6+A4=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://www.draw.io/js/viewer.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Kubernetes-용어-정리&quot;&gt;&lt;a href=&quot;#Kubernetes-용어-정리&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes 용어 정리&quot;&gt;&lt;/a&gt;Kubernetes 용어 정리&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="kubernetes" scheme="https://poikilo.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Github 블로그 생성</title>
    <link href="https://poikilo.github.io/2020/02/26/first-post/"/>
    <id>https://poikilo.github.io/2020/02/26/first-post/</id>
    <published>2020-02-26T01:42:44.000Z</published>
    <updated>2020-03-02T21:46:28.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="기술블로그-Start"><a href="#기술블로그-Start" class="headerlink" title="기술블로그 Start"></a>기술블로그 Start</h3><hr><p>2020-02-26 3번째 회사의 퇴사를 앞두고, 보안사항이 아닌 개발관련 정리내용을 옮기기로 결심.<br>Confluence의 개인 공간에 작성해 두었던 기술관련 정리내용들을 옮겨보려 했다.</p><h3 id="hexo를-선택하게-된-이유"><a href="#hexo를-선택하게-된-이유" class="headerlink" title="hexo를 선택하게 된 이유"></a>hexo를 선택하게 된 이유</h3><hr><p>github 블로그를 생성하는 개발자에게 인기가 많은 프레임워크는 아래 3종이 있다.  </p><ul><li>jekyll<ul><li>가장 많은 사용자를 보유하고 있다.<ul><li>한글 사용법, 다양한 테마 지원 등의 강점이 있다.</li></ul></li><li>ruby 기반의 프레임워크이다.<ul><li>이부분이 나한테는 단점으로 다가왔다.</li></ul></li></ul></li><li>Hexo<ul><li>nodejs 기반의 프레임워크이다.<ul><li>node-express를 사용해본 사람이라면, ejs 문법도 그렇게 어렵지 않다.</li><li>kubernetes, helm, gitlab을 사용해본 경험으로 YAML configuration 문법이 좀 더 쉽게 다가왔다.</li></ul></li><li>기본 테마, 깔끔한 템플릿은 많이 있다.</li><li>git으로 포스트 버전관리가 안된다.<ul><li>별도 포스트 버전관리를 위한 저장소를 지정하고</li><li>배포를 지원하는 hexo-deployer-git node package를 사용하여 포스팅 하기로 결정했다.</li></ul></li></ul></li><li>Hugo<ul><li>go lang 기반으로 만들어졌으며, 빠르다는 강점이 있다.<ul><li>필자는 jekyll과 hexo만 사용해봤으며, 좀 더 쉽게 configuration 할 수 있는 hexo를 선택하게 되었다.</li></ul></li></ul></li></ul><h3 id="clean-blog-theme-를-선택하게-된-이유"><a href="#clean-blog-theme-를-선택하게-된-이유" class="headerlink" title="clean-blog theme 를 선택하게 된 이유"></a>clean-blog theme 를 선택하게 된 이유</h3><hr><p>크게 다른이유는 없다..<br>cresumerjang님 블로그를 참고하여, 진행하다보니<br>comment, discussion 하는 library(disqus)를 사용하기 위해 선택하게 되었다.</p><h3 id="HEXO-블로그-입문-참고-첫-블로그-포스팅"><a href="#HEXO-블로그-입문-참고-첫-블로그-포스팅" class="headerlink" title="HEXO 블로그 입문 참고 - 첫 블로그 포스팅."></a>HEXO 블로그 입문 참고 - 첫 블로그 포스팅.</h3><hr><p><a href="https://cresumerjang.github.io/2019/01/17/hexo-start-manual/" target="_blank" rel="noopener">cresumerjang님 블로그 :: hexo 블로그 입문 가이드</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;기술블로그-Start&quot;&gt;&lt;a href=&quot;#기술블로그-Start&quot; class=&quot;headerlink&quot; title=&quot;기술블로그 Start&quot;&gt;&lt;/a&gt;기술블로그 Start&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;2020-02-26 3번째 회사의 퇴사를 앞두고, 보
      
    
    </summary>
    
    
    
      <category term="blog" scheme="https://poikilo.github.io/tags/blog/"/>
    
      <category term="begineer" scheme="https://poikilo.github.io/tags/begineer/"/>
    
  </entry>
  
</feed>
